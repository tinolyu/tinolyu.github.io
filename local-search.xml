<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2020年的读书记录</title>
    <link href="/2020/08/22/2020-05-06-2020%E5%B9%B4%E7%9A%84%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/08/22/2020-05-06-2020%E5%B9%B4%E7%9A%84%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>感谢微信读书！感谢新星出版社！多读书，读好书！2020年小吕依旧毫无创意地热爱着有点枯燥无聊的推理小说📚</p></blockquote><a id="more"></a><p>写这个博客的时候2020年上半场就要结束了，呆在隔离的酒店里不知道做些什么。这几个月过得很忙乱，实习的笔试面试，学不会的finance和economy，COVID-19，搁浅的日本之旅，cc的project，事事难过事事过吧，只能这样安慰自己了。结果就是书没怎么读，写了一堆废话来找借口，隐瞒本人精神世界的空虚。<br>希望今年多读几本书，并在这里分享一下我的（没有任何意义的）感受，边读边写吧！</p><p><em>感谢微信读书！感谢新星出版社！有泄底！！！！泄底！！！泄底！！！</em><br><em>2019年的链接： <a href="https://www.tinolyu.com/2020/01/07/2020-01-07-2019%E5%B9%B4%E7%9A%84%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/">请点我</a></em></p><h2 id="《刺青杀人事件》"><a href="#《刺青杀人事件》" class="headerlink" title="《刺青杀人事件》"></a>《<a href="https://book.douban.com/subject/10518843/">刺青杀人事件</a>》</h2><p>为什么会读这本书呢，因为去年我心血来潮在左右胳膊文了两个图案。日本的刺青和普通的文身其实是不大一样，被叫做入れ墨，多见于黑社会成员的后背。<br>密室杀人+身份调换，动过文身念头的人可能都会想到这种手法，有点乏味，但刺青图案背后的神话故事让这本书变得有点玄乎。  </p><h2 id="《虹の歯ブラシ-上木らいち発散》"><a href="#《虹の歯ブラシ-上木らいち発散》" class="headerlink" title="《虹の歯ブラシ 上木らいち発散》"></a>《<a href="https://book.douban.com/subject/26285818/">虹の歯ブラシ 上木らいち発散</a>》</h2><p>这本书是绝对的年度最佳！！！！！！！我找不到更🐂🍺的词汇去形容它，读完后我心情激动，久久不能平复！早坂吝是天才！<br>是色情小说吗？那可不合格，不够工口。是推理小说吗？并没有华丽的杀人手法，没有构造复杂的建筑物，甚至几篇根本没有杀人事件。青は海とマニキュアの色 这一篇，是我看过的最强的叙诡，赤は上木らいち自身の色 这一篇则简直是作者的炫技了。<br>读它！但我强烈不建议日系推理入门新手阅读<br>【txt下载】豆瓣民翻：<a href="https://uploadpicuse.blob.core.windows.net/pictures/%E5%BD%A9%E8%99%B9%E7%89%99%E5%88%B7.txt">https://uploadpicuse.blob.core.windows.net/pictures/彩虹牙刷.txt</a><br>（机智地上传到了Azure blob）    </p><h2 id="《尸人庄谜案》"><a href="#《尸人庄谜案》" class="headerlink" title="《尸人庄谜案》"></a>《<a href="https://book.douban.com/subject/30396712/">尸人庄谜案</a>》</h2><p>因为神木DD和美波MM演了电影版，我便慕名去看了原作小说。人设简直就是轻小说系，天才美少女侦探这种角色都出现了，竟然还不动画化？！故事背景确实很吸引人，生化危机环境下的推理小说，属于可以一口气读下去地那种类型。但这个手法呢，就一般吧，作为出道作蛮强的。</p><h2 id="《我们盗走星座的理由》"><a href="#《我们盗走星座的理由》" class="headerlink" title="《我们盗走星座的理由》"></a>《<a href="https://book.douban.com/subject/34860553/">我们盗走星座的理由</a>》</h2><p>这书名，多文艺，多清新，多有内涵！《相思病》还算ok，《妖精的学校》没读懂，看了这个<a href="https://book.douban.com/review/12156015/">科普</a>，还是不懂，《骗子绅士》完全没印象了，《终焉童话》有点魔幻的推理，《我们盗走星座的理由》里的小男孩真的太会了，学习了。  </p><h2 id="《斬首循環》"><a href="#《斬首循環》" class="headerlink" title="《斬首循環》"></a>《<a href="https://book.douban.com/subject/1794287/">斬首循環</a>》</h2><p> 时隔多年又一次读了西尾维新老师的书，这本是真·轻小说，手法很没劲，登场角色一个个的全是人设鲜明的美少女搭配一个废柴(?)男主，唉！怎么硕呢，我已经过了犯中二病的年纪了！  </p><h2 id="《推理竞技场》"><a href="#《推理竞技场》" class="headerlink" title="《推理竞技场》"></a>《<a href="https://book.douban.com/subject/30428949/">推理竞技场</a>》</h2><p>这本蛮有趣的，读完基本知道了推理小说的种种套路，N层反转，说起来我真的很喜欢有剧情反转的推理小说，虽然是伪解答，但能编出那么多伪解答也是辛苦作者了。<br>（结尾的真解答超展开是来搞笑的吗）  </p><h2 id="《醉步男》"><a href="#《醉步男》" class="headerlink" title="《醉步男》"></a>《<a href="https://book.douban.com/subject/30359030/">醉步男</a>》</h2><p>今年到目前读的唯一一本科幻小说，时间旅行那套，年纪大了不喜欢读费脑子的书，跳来跳去了，最后女主是个啥我也没读懂，唉！<br>附了一个恐怖小短篇《玩具修理者》，我蛮喜欢，有乙一内味儿了，够变态，够魔幻的。  </p><h2 id="《非人类》"><a href="#《非人类》" class="headerlink" title="《非人类》"></a>《<a href="https://book.douban.com/subject/33476138/">非人类</a>》</h2><p>绫辻行人的短篇集，很没劲，非常没劲，这就是没被收录的原因吧，没有一个有意思的故事。  </p><h2 id="《赤朽叶家的传说》"><a href="#《赤朽叶家的传说》" class="headerlink" title="《赤朽叶家的传说》"></a>《<a href="https://book.douban.com/subject/20440568/">赤朽叶家的传说</a>》</h2><p>难得读了一本纸质书，在从阿德莱德飞厦门的航班上看了一大半。以为是推理小说才开始读的，然后发现推理的情节只在最后10%。书不厚，但写了赤朽叶家的女人三个世代的故事，千里眼万叶，不良少女漫画家毛毬和普通的“我”。<br>去年去熊野古道徒步的时候感觉自己是很真实地沉浸在一种神秘的神话氛围里，这本书所描绘的场景也给我这种感觉。说起出云国啊，日本神话啊，我超超超超级感兴趣。    </p><h2 id="《水母不会冻结》"><a href="#《水母不会冻结》" class="headerlink" title="《水母不会冻结》"></a>《<a href="https://book.douban.com/subject/32494889/">水母不会冻结</a>》</h2><p>书名真是莫名其妙的。看到有人把这本书和绫辻行人的《十角馆事件》对比，那差得可不是一星半点，《十角馆》不管是华丽程度还是手法设计都比《水母》强n个level，我对欧美人名有阅读障碍也是一点，拜托日系推理别搞欧美人设了好不好！！！  </p><h2 id="《独眼少女》"><a href="#《独眼少女》" class="headerlink" title="《独眼少女》"></a>《<a href="https://book.douban.com/subject/25918073/">独眼少女</a>》</h2><p>去年读了好几本麻神的书，今年刚刚读了这一本。还还还还还是麻神最上手的崩坏流，反转反转反转，为了反转而反转，刚刚看到20%的进度就有解答，这能是真解答吗我说，推理也太随意了。女主：凶手是你 -&gt; 不对凶手其实是她 -&gt; 没想到吧其实是他 -&gt; 真正的凶手其实是我啦傻孩子，男主：种田静马-&gt;缩写就是种马了！-&gt;没有感情的生殖机器。男主很惨，栖苅一家更惨。</p><h2 id="《坡道上的家》"><a href="#《坡道上的家》" class="headerlink" title="《坡道上的家》"></a>《<a href="https://book.douban.com/subject/34911983/">坡道上的家</a>》</h2><p>闲着无聊读的，这本书比我想象的更无聊。所谓的“年度女性发声之作”，但我个人认为咱国女性其实无法与这本书同感。<br>看日本的综艺和电视剧，其实展示出来的也更多是敢爱敢恨、敢说敢做、自我且洒脱的女性，真正压抑的也不能放在电视说不是。  </p><h2 id="《黑暗中飘香的谎言》"><a href="#《黑暗中飘香的谎言》" class="headerlink" title="《黑暗中飘香的谎言》"></a>《<a href="https://book.douban.com/subject/34792523/">黑暗中飘香的谎言</a>》</h2><p>要不是写读书总结我怕是都记不起来自己读过这本书。比较新颖的第一人称推理小说，二战留中遗孤也是个很少见于推理小说中的社会题材，但就是某些情节读着不大舒服，感觉作者在刻意美化日本。再说说手法，我就在此泄底了，双胞胎诡计，要我说用这诡计的推理就不应该被出版，逗你玩儿嘛不是，就算是社会推理也不能这么乱来！  </p><h2 id="《消失的13级台阶》"><a href="#《消失的13级台阶》" class="headerlink" title="《消失的13级台阶》"></a>《<a href="https://book.douban.com/subject/34996429/">消失的13级台阶</a>》</h2><p>同样是社会派推理，这本就很不错，情节很精彩，故事很完整，意义很深刻，后面几章还莫名有点冒险要素。但看完后我也不禁会想树原亮被无故关在监狱里的10年又有什么可以弥补呢？  </p><h2 id="《诡计博物馆》、《密室收藏家》、《绝对不在场证明》"><a href="#《诡计博物馆》、《密室收藏家》、《绝对不在场证明》" class="headerlink" title="《诡计博物馆》、《密室收藏家》、《绝对不在场证明》"></a>《<a href="https://book.douban.com/subject/35016085/">诡计博物馆</a>》、《<a href="https://book.douban.com/subject/26348596/">密室收藏家</a>》、《<a href="https://book.douban.com/subject/34998167/">绝对不在场证明</a>》</h2><p>三本大山诚一郎的短篇主题推理小说集放在一起说，诡计博物馆全是关于身份互换的推理故事，密室收藏家和绝对不在场证明看书名就知道主题。<br>我最喜欢的是第一本，侦探角色塑造得比较好，冷漠而智慧的黑长直美女警官，很有魅力！而且每篇故事都水平相当，没有稍稍逊色的，我好奇作者到底是怎么想出来这么多不带重样儿的身份互换诡计出来的。密室和不在场相比下来就只能说还可以了，看过就忘的那种，不在场被改编日剧了，东宝小公主浜边美波主演，看看颜就好了。  </p><h2 id="《体育馆之谜》、《水族馆之谜》、《图书馆之谜》、《风之丘五十元硬币之谜》"><a href="#《体育馆之谜》、《水族馆之谜》、《图书馆之谜》、《风之丘五十元硬币之谜》" class="headerlink" title="《体育馆之谜》、《水族馆之谜》、《图书馆之谜》、《风之丘五十元硬币之谜》"></a>《<a href="https://book.douban.com/subject/27054451/">体育馆之谜</a>》、《<a href="https://book.douban.com/subject/30159798/">水族馆之谜</a>》、《<a href="https://book.douban.com/subject/30159888/">图书馆之谜</a>》、《<a href="https://book.douban.com/subject/33390352/">风之丘五十元硬币之谜</a>》</h2><p>青崎有吾的四本也放在一起，有一说一，这一系列的推理小说真的一股后宫向轻小说既视感，青梅竹马、黑历史前女友、傲娇妹妹、高冷优等生、运动系解密提示器女主加上看似废物实则深藏不露的宅男侦探男主角，爷的青春回来了，顺便一提我是袴田妹子派。<br>但话说回来，虽然是轻松愉快的校园推理，没有什么猎奇连续杀人案，但非常本格，尤其是那记不住的出场人物表，很有本格内味儿哈哈哈。前三本是正经推理，我比较喜欢体育馆，风之丘是日常向的，有点冰菓的意思，高中生嘛，还是别整天凑杀人事件的热闹！  </p><h2 id="《网内人》"><a href="#《网内人》" class="headerlink" title="《网内人》"></a>《<a href="https://book.douban.com/subject/34262174/">网内人</a>》</h2><p>陈浩基在我这儿封神了！读纯正华文推理就是和读译本不一样，而且没想到读社会推理还能有这么精彩的叙诡，套路有点像《爱的成人式》，就是结尾跑偏写成霸道总裁爱上我了。本书总结起来就是，读网内人，学习无线网路入门技术(?)。  </p><h2 id="《13-67》"><a href="#《13-67》" class="headerlink" title="《13 67》"></a>《<a href="https://book.douban.com/subject/25897884/">13 67</a>》</h2><p>可以当选本人最爱的小说了，同样是陈浩基的作品。  倒叙写了几个零碎的警察故事，侧面反映了几个时代转折点下的香港，结尾绝妙地连上了开头，看完差点儿没缓过来（夸张了）。确实是香港作家才写得出来的魅力，这本推理小说真厉害！  </p><h2 id="《尼罗河上的惨案》、《复仇女神》、《加勒比海之谜》、《伯特伦旅馆》、《沉睡谋杀案》、《马普尔小姐最后的案件》、《底牌》"><a href="#《尼罗河上的惨案》、《复仇女神》、《加勒比海之谜》、《伯特伦旅馆》、《沉睡谋杀案》、《马普尔小姐最后的案件》、《底牌》" class="headerlink" title="《尼罗河上的惨案》、《复仇女神》、《加勒比海之谜》、《伯特伦旅馆》、《沉睡谋杀案》、《马普尔小姐最后的案件》、《底牌》"></a>《<a href="https://book.douban.com/subject/1818347/">尼罗河上的惨案</a>》、《<a href="https://book.douban.com/subject/26586494/">复仇女神</a>》、《<a href="https://book.douban.com/subject/30133215/">加勒比海之谜</a>》、《<a href="https://book.douban.com/subject/30236316/">伯特伦旅馆</a>》、《<a href="https://book.douban.com/subject/25973215/">沉睡谋杀案</a>》、《<a href="https://book.douban.com/subject/26777977/">马普尔小姐最后的案件</a>》、《<a href="https://book.douban.com/subject/24852594/">底牌</a>》</h2><p>新星出版社为了纪念阿婆诞辰130周年搞了个9月每天读书打卡的活动，我便开心参加了，读了这7本书，完成了今年的读书小小目标，补完马普尔小姐系列。阿婆的书一共也没几页，无聊时的休闲读物，上面这些里我比较推荐沉睡谋杀案和底牌，一本有点情节有点诡异很吸引我，一本反转比较多的读起来很爽。  </p><h2 id="《绝叫》"><a href="#《绝叫》" class="headerlink" title="《绝叫》"></a>《<a href="https://book.douban.com/subject/35031587/">绝叫</a>》</h2><p>社会派推理+1，第一人称+第二人称+第三人称绝妙地融合在一起，尤其是结尾人称的突然转变让人大呼过瘾。书中涉及到很多当下很火的议题，关于原生家庭、关于独立女性，属于那种可以引发思考的小说吧，但我这儿是没什么深刻的见解啦，读着痛快就好了。<br>下面是泄底，我比较喜欢的两个小伏笔： 一个是阳子小时候对一个避风港的渴望，家庭不是阳子的避风港、学校不是阳子的避风港，经历了一切后她回到原来的地方开了家咖啡店，并希望这里能够成为别人的避风港，虽然书封上将阳子称作恶女，但我想她其实也是善良的。另一个是琉华，她决定辞掉应召女的工作嫁人生子，最后却成为了把孩子殴打致死的恶魔母亲，这段剧情通过孩子的名字前后呼应。  </p><h2 id="《圣母》"><a href="#《圣母》" class="headerlink" title="《圣母》"></a>《<a href="https://book.douban.com/subject/30475757/">圣母</a>》</h2><p>泄底。叙诡真好啊，我爱叙诡。<br>开头读到真琴，我以为是女孩子，再往后读，有女生向ta告白，啊原来是男孩子，再往后读，揭晓身份出现人称代词“她”，啊原来还是女孩子，是我太局限了，这是一层性别叙诡。再往后读，原来女儿不是那个女儿，妈妈不是那个妈妈，这是一层身份叙诡。</p><h2 id="《魔眼之匣谜案》"><a href="#《魔眼之匣谜案》" class="headerlink" title="《魔眼之匣谜案》"></a>《<a href="https://book.douban.com/subject/35049753/">魔眼之匣谜案</a>》</h2><p>今年竟然读到了魔眼之匣的简中版，买了实体书但最后还是在微信读书上凑活了，设定上不如尸人庄，手法上还是强一些，续作继续安排上！我还要看美少女侦探破案！  </p><h2 id="《高清日本战国史1》"><a href="#《高清日本战国史1》" class="headerlink" title="《高清日本战国史1》"></a>《<a href="https://book.douban.com/subject/27106753/">高清日本战国史1</a>》</h2><p>看真田丸的时候突然发现日本战国史还挺有趣的就随便找了一本读，这套书一共四本，我一本弃了，历史的进程大概是到丰臣秀吉统一全国。可以看出作者在模仿明朝那些事儿的风格，但说到底日本战国也就是县长打架，今天我投靠你明天我投靠他的故事，读后感觉织田信长这个人物蛮有魅力，本能寺参拜安排上。  </p><h2 id="《死亡通知单·暗黑者》-《暗黑者2：宿命》-《暗黑者：离别曲》-《暗黑者外传：惩罚》"><a href="#《死亡通知单·暗黑者》-《暗黑者2：宿命》-《暗黑者：离别曲》-《暗黑者外传：惩罚》" class="headerlink" title="《死亡通知单·暗黑者》 《暗黑者2：宿命》 《暗黑者：离别曲》 《暗黑者外传：惩罚》"></a>《<a href="https://book.douban.com/subject/25884890/">死亡通知单·暗黑者</a>》 《<a href="https://book.douban.com/subject/30729970/">暗黑者2：宿命</a>》 《<a href="https://book.douban.com/subject/26693258/">暗黑者：离别曲</a>》 《<a href="https://book.douban.com/subject/26614581/">暗黑者外传：惩罚</a>》</h2><p>我愿称周浩晖老师的暗黑者系列为刑侦爽文，很难不喜欢上反派，冷静、聪明而且是个帅哥，反正我粉了！四本书的文字量比较多，但很容易读进去，一周摸个鱼的时间就看完，还是国产书好啊，没有读译本的生硬感！最爱第二本，第三本也不错，第一本次之，最后一本不行，因为没有小E嘻嘻。</p>]]></content>
    
    
    <categories>
      
      <category>reading</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Minesweeper Game Design</title>
    <link href="/2020/08/22/2020-08-22-Minesweeper-Game-Design/"/>
    <url>/2020/08/22/2020-08-22-Minesweeper-Game-Design/</url>
    
    <content type="html"><![CDATA[<blockquote><p>人生苦短，我玩扫雷</p></blockquote><a id="more"></a><p>小吕很爱玩儿游戏，这些年来，3a大作玩过不少，有口碑的独立游戏也有过接触，但唯一始终无法放弃的只有扫雷。2019年10月的某天，我在微博痛心疾首的写下下文：  </p><blockquote><p>2017年的冬天，那时的我没有24小时热水的家，不会继承多态，for循环可以看一天，日子很简单。C++期末前夜，我在对外经济贸易大学西门外的咖啡陪你下载了windows应用商店的扫雷，并在6个小时后第一次通关了扫雷（耗时800秒），虽然C++题库还差63885道题没有看。从那天起，我玩啊玩啊，在中级微观经济学课上，在金融风险管理课上，在数据结构课上，我玩花了眼，玩坏了手，玩掉了发，但我就是…不能……停…下…来，越焦虑我就越想扫，越扫我就越焦虑，越焦虑越扫，越扫越焦虑……在异国他乡，我又一次深刻地忏悔，我告诉自己，也告诉别人：年纪轻轻的，别碰扫雷。    </p></blockquote><p>很凑巧，今天在leetcode上偶遇一道关于<a href="https://leetcode-cn.com/problems/minesweeper/">扫雷的题目</a>，dfs算法已经摆这儿了，我想这是个机会自己想想做出来一个属于自己的扫雷游戏。<br>先把题解写这儿：  </p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span>[][] updateBoard(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span>[] click) &#123;        <span class="hljs-keyword">int</span> x = click[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> y = click[<span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span>(board[x][y] == <span class="hljs-string">&#x27;M&#x27;</span>) &#123;            board[x][y] = <span class="hljs-string">&#x27;X&#x27;</span>;            <span class="hljs-keyword">return</span> board;        &#125;        dfs(board, click[<span class="hljs-number">0</span>], click[<span class="hljs-number">1</span>]);        <span class="hljs-keyword">return</span> board;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] x_mov = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;        <span class="hljs-keyword">int</span>[] y_mov = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;            <span class="hljs-keyword">if</span>(isInside(board, x + x_mov[i], y + y_mov[i])) &#123;                <span class="hljs-keyword">if</span>(board[x + x_mov[i]][y + y_mov[i]] == <span class="hljs-string">&#x27;M&#x27;</span>) &#123;                    count++;                &#125;            &#125;        &#125;        <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>) &#123;            board[x][y] = <span class="hljs-string">&#x27;B&#x27;</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;                <span class="hljs-keyword">if</span>(isInside(board, x + x_mov[i], y + y_mov[i]) &amp;&amp; board[x + x_mov[i]][y + y_mov[i]] == <span class="hljs-string">&#x27;E&#x27;</span>) &#123;                    dfs(board, x + x_mov[i], y + y_mov[i]);                &#125;            &#125;        &#125;        <span class="hljs-keyword">else</span> &#123;            board[x][y] = (<span class="hljs-keyword">char</span>)(count + <span class="hljs-string">&#x27;0&#x27;</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isInside</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; board.length &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; board[<span class="hljs-number">0</span>].length;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>game</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>刷题记录</title>
    <link href="/2020/04/11/2020-04-11-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/04/11/2020-04-11-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>主要在这里记录一下自己刷到的一些有点疑惑的题，来自leetcode和lintcode。目前有分治法&amp;遍历、动态规划、双指针、BFS &amp; DFS等类型的题目记录在案！小吕啊小吕，就你这水平，还不多刷点题！</p></blockquote><a id="more"></a><h1 id="分治法-amp-遍历"><a href="#分治法-amp-遍历" class="headerlink" title="分治法&amp;遍历"></a>分治法&amp;遍历</h1><h2 id="Lowest-Common-Ancestor-III"><a href="#Lowest-Common-Ancestor-III" class="headerlink" title="Lowest Common Ancestor III"></a><a href="https://www.lintcode.com/problem/lowest-common-ancestor-iii/description">Lowest Common Ancestor III</a></h2><p>Description:<br>Given the root and two nodes in a Binary Tree. Find the lowest common ancestor(LCA) of the two nodes.<br>The lowest common ancestor is the node with largest depth which is the ancestor of both nodes.<br>Notice:<br>node A or node B may not exist in tree.<br>Each node has a different value<br>Return null if LCA does not exist.<br><img src="https://s1.ax1x.com/2020/08/04/aD1Tvd.png"><br><img src="https://s1.ax1x.com/2020/08/04/aD1xPS.png">  </p><p>思路：把需要的东西都放在return里，建立一个新的returnType类。<br>1.如果右子树和左子树都有要找的值，返回根节点。<br>2.如果仅左子树/右子树有要找的值，则结果在左子树/右子树中。<br>需要额外注意root即为a或b的情况，同时要判断a/b是否存在。  </p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition of TreeNode:</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     public int val;</span><span class="hljs-comment"> *     public TreeNode left, right;</span><span class="hljs-comment"> *     public TreeNode(int val) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = this.right = null;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">returnType</span> </span>&#123;    <span class="hljs-keyword">boolean</span> a_exist;    <span class="hljs-keyword">boolean</span> b_exist;    TreeNode node;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">returnType</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> a_exist, <span class="hljs-keyword">boolean</span> b_exist, TreeNode node)</span> </span>&#123;        <span class="hljs-keyword">this</span>.a_exist = a_exist;        <span class="hljs-keyword">this</span>.b_exist = b_exist;        <span class="hljs-keyword">this</span>.node = node;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">     * @param root: The root of the binary tree.</span><span class="hljs-comment">     * @param A: A TreeNode</span><span class="hljs-comment">     * @param B: A TreeNode</span><span class="hljs-comment">     * @return: Return the LCA of the two nodes.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor3</span><span class="hljs-params">(TreeNode root, TreeNode A, TreeNode B)</span> </span>&#123;        <span class="hljs-comment">// write your code here</span>        returnType r = helper(root, A.val, B.val);        <span class="hljs-keyword">if</span>(r.a_exist &amp;&amp; r.b_exist) &#123;            <span class="hljs-keyword">return</span> r.node;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> returnType <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode node, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> returnType(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);        &#125;        returnType left_part = helper(node.left, a, b);        returnType right_part = helper(node.right, a, b);                <span class="hljs-keyword">boolean</span> a_exist = left_part.a_exist || right_part.a_exist || node.val == a;        <span class="hljs-keyword">boolean</span> b_exist = left_part.b_exist || right_part.b_exist || node.val == b;                <span class="hljs-keyword">if</span>(node.val == a || node.val == b) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> returnType(a_exist, b_exist, node);        &#125;        <span class="hljs-keyword">if</span>(left_part.node != <span class="hljs-keyword">null</span> &amp;&amp; right_part.node != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> returnType(a_exist, b_exist, node);        &#125;        <span class="hljs-keyword">if</span>(left_part.node != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> returnType(a_exist, b_exist, left_part.node);        &#125;        <span class="hljs-keyword">if</span>(right_part.node != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> returnType(a_exist, b_exist, right_part.node);        &#125;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> returnType(a_exist, b_exist, <span class="hljs-keyword">null</span>);    &#125;&#125;</code></pre><h2 id="Kth-Smallest-Element-in-a-BST"><a href="#Kth-Smallest-Element-in-a-BST" class="headerlink" title="Kth Smallest Element in a BST"></a><a href="https://www.lintcode.com/problem/kth-smallest-element-in-a-bst/description">Kth Smallest Element in a BST</a></h2><p>Description:<br>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.<br>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.<br><img src="https://s1.ax1x.com/2020/08/04/aD3pvj.png">  </p><p>思路：BST中，左子树的值比右子树小。遍历BST，存入每一个subtree的node数，判断左子树的node数/左子树的node数+1和k的关系。  </p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition of TreeNode:</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     public int val;</span><span class="hljs-comment"> *     public TreeNode left, right;</span><span class="hljs-comment"> *     public TreeNode(int val) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = this.right = null;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root: the given BST</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> k: the given k</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: the kth smallest element in BST</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-comment">// write your code here</span>        HashMap&lt;TreeNode, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt; ();        getNumNode(root, map);        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">if</span>(map.get(root.left) &gt;= k) &#123;            <span class="hljs-keyword">return</span> kthSmallest(root.left, k);        &#125;        <span class="hljs-keyword">if</span>(map.get(root.left) + <span class="hljs-number">1</span> == k) &#123;            <span class="hljs-keyword">return</span> root.val;        &#125;        <span class="hljs-keyword">return</span> kthSmallest(root.right, k - map.get(root.left) - <span class="hljs-number">1</span>);    &#125;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumNode</span><span class="hljs-params">(TreeNode root, HashMap&lt;TreeNode, Integer&gt; map)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) &#123;            map.put(root, <span class="hljs-number">0</span>);            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;         <span class="hljs-keyword">int</span> left = getNumNode(root.left, map);        <span class="hljs-keyword">int</span> right = getNumNode(root.right, map);        <span class="hljs-keyword">if</span>(!map.containsKey(root)) map.put(root, left + right+ <span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> left + right+ <span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h2 id="Validate-Binary-Search-Tree"><a href="#Validate-Binary-Search-Tree" class="headerlink" title="Validate Binary Search Tree"></a><a href="https://www.lintcode.com/problem/validate-binary-search-tree/description">Validate Binary Search Tree</a></h2><p>Description:<br>Given a binary tree, determine if it is a valid binary search tree (BST).<br>Assume a BST is defined as follows:<br>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.<br>A single node tree is a BST<br><img src="https://s1.ax1x.com/2020/08/04/aD3KM9.png"><br>思路：（分治法）判断BST需要判断左子树和右子树是否均为BST，且左子树的最大值&lt;root.val&lt;右子树的最小值，为了记录subtree的最小值和最大值，需要建立一个returnType存放这些信息。   </p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition of TreeNode:</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     public int val;</span><span class="hljs-comment"> *     public TreeNode left, right;</span><span class="hljs-comment"> *     public TreeNode(int val) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = this.right = null;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">returnType</span> </span>&#123;    <span class="hljs-keyword">int</span> maxV;    <span class="hljs-keyword">int</span> minV;    <span class="hljs-keyword">boolean</span> isValid;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">returnType</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxV, <span class="hljs-keyword">int</span> minV, <span class="hljs-keyword">boolean</span> isValid)</span> </span>&#123;        <span class="hljs-keyword">this</span>.maxV = maxV;        <span class="hljs-keyword">this</span>.minV = minV;        <span class="hljs-keyword">this</span>.isValid = isValid;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root: The root of binary tree.</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: True if the binary tree is BST, or false</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-comment">// write your code here</span>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">return</span> helper(root).isValid;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> returnType <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> returnType(root.val, root.val, <span class="hljs-keyword">true</span>);        &#125;                <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span>) &#123;            returnType right_part = helper(root.right);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> returnType(right_part.maxV, root.val, root.val &lt; right_part.minV &amp;&amp; right_part.isValid);        &#125;        <span class="hljs-keyword">if</span>(root.right == <span class="hljs-keyword">null</span>) &#123;            returnType left_part = helper(root.left);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> returnType(root.val, left_part.minV, root.val &gt; left_part.maxV &amp;&amp; left_part.isValid);        &#125;        returnType right_part = helper(root.right);        returnType left_part = helper(root.left);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> returnType(right_part.maxV, left_part.minV, left_part.maxV &lt; root.val &amp;&amp; right_part.minV &gt; root.val &amp;&amp; right_part.isValid &amp;&amp; left_part.isValid);    &#125;    &#125;</code></pre><h2 id="Sort-Colors-II"><a href="#Sort-Colors-II" class="headerlink" title="Sort Colors II"></a><a href="https://www.lintcode.com/problem/sort-colors-ii/description">Sort Colors II</a></h2><p>Description:<br>Given an array of n objects with k different colors (numbered from 1 to k), sort them so that objects of the same color are adjacent, with the colors in the order 1, 2, … k.<br><img src="https://ae01.alicdn.com/kf/Ue9522c9970c54102897b644926e069ffP.jpg"><br>思路：类似于快速排序，根据中间的颜色的数partition，左边小于中间的颜色，右边大于中间的颜色，然后两边继续做同样的操作。  </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> colors: A list of integer</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> k: An integer</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: nothing</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] colors, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-comment">// write your code here</span>        sortColors2(colors, k, <span class="hljs-number">0</span>, colors.length - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, k);    &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] colors, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> from, <span class="hljs-keyword">int</span> to)</span> </span>&#123;        <span class="hljs-comment">// write your code here</span>        <span class="hljs-keyword">if</span>(left == right) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span>(from == to) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">int</span> l = left, r = right;        <span class="hljs-keyword">int</span> mid = (to - from) / <span class="hljs-number">2</span> + from;        <span class="hljs-keyword">while</span>(l &lt;= r) &#123;            <span class="hljs-keyword">while</span>(l &lt;= r &amp;&amp; colors[l] &lt;= mid) &#123;                l++;            &#125;            <span class="hljs-keyword">while</span>(l &lt;= r &amp;&amp; colors[r] &gt; mid) &#123;                r--;            &#125;            <span class="hljs-keyword">if</span>(l &lt;= r) &#123;                <span class="hljs-keyword">int</span> temp = colors[l];                colors[l] = colors[r];                colors[r] = temp;                l++;                r--;            &#125;        &#125;        sortColors2(colors, k, left, l, from, mid);        sortColors2(colors, k, l, right, mid + <span class="hljs-number">1</span>, to);    &#125;&#125;</code></pre><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="Paint-House"><a href="#Paint-House" class="headerlink" title="Paint House"></a><a href="https://www.lintcode.com/problem/paint-house/description">Paint House</a></h2><p>Description:<br>There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color, and you need to cost the least. Return the minimum cost.<br>The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on… Find the minimum cost to paint all houses.<br><img src="https://ae01.alicdn.com/kf/U642bc06486f44b749f04548405909129h.jpg"><br>思路：使用动态规划，第i个房子的颜色与第i-1个房子的颜色不同，且为涂到第i-1个房子的费用最小值+第i个房子的费用。建立二维数组，helper[i][j]代表第i个房子涂第j个颜色时的总费用最小值。<br>转移方程为：f[i][j] = min{f[n-1][k]} + costs[i][j != k]<br>(可以使用[2][3]的滚动数组节省空间，第i个房子的颜色/费用只与第i-1个房子的颜色/费用有关)</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> costs: n x 3 cost matrix</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: An integer, the minimum cost to paint all houses</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minCost</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] costs)</span> </span>&#123;        <span class="hljs-comment">// write your code here</span>        <span class="hljs-keyword">if</span>(costs == <span class="hljs-keyword">null</span> || costs.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;                <span class="hljs-keyword">int</span>[][] helper = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[costs.length][<span class="hljs-number">3</span>];        helper[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = costs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];        helper[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = costs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];        helper[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = costs[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; costs.length; i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;                helper[i][j] = Integer.MAX_VALUE;            &#125;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">3</span>; k++) &#123;                    <span class="hljs-keyword">if</span>(k != j &amp;&amp; helper[i - <span class="hljs-number">1</span>][k] + costs[i][j] &lt; helper[i][j]) &#123;                        helper[i][j] = helper[i - <span class="hljs-number">1</span>][k] + costs[i][j];                    &#125;                &#125;            &#125;        &#125;                <span class="hljs-keyword">int</span> result = helper[costs.length - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];        <span class="hljs-keyword">if</span>(helper[costs.length - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &lt; result) &#123;            result = helper[costs.length - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">if</span>(helper[costs.length - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] &lt; result) &#123;            result = helper[costs.length - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><h2 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a><a href="https://leetcode-cn.com/problems/word-break/">单词拆分</a></h2><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。<br>说明：<br>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br><img src="https://s1.ax1x.com/2020/08/04/aD104U.png">  </p><p>思路：转移方程为dp[i] = dp[j] &amp;&amp; wordDict.contains(s[j:i])</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;        Set&lt;String&gt; words = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(wordDict);        <span class="hljs-keyword">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[s.length() + <span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= s.length(); i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;                <span class="hljs-keyword">if</span>(dp[j] == <span class="hljs-keyword">true</span> &amp;&amp; words.contains(s.substring(j, i))) &#123;                    dp[i] = <span class="hljs-keyword">true</span>;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[s.length()];    &#125;&#125;</code></pre><h2 id="Coin-Change"><a href="#Coin-Change" class="headerlink" title="Coin Change"></a><a href="https://leetcode-cn.com/problems/coin-change/">Coin Change</a></h2><p><img src="https://ae01.alicdn.com/kf/Ua808b0c02b99458991e54e44c0d17efdK.jpg">  </p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; amount + <span class="hljs-number">1</span>; i++) &#123;            dp[i] = amount + <span class="hljs-number">1</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c : coins) &#123;                <span class="hljs-keyword">if</span>(i - c &gt;= <span class="hljs-number">0</span>) &#123;                    dp[i] = Math.min(dp[i], <span class="hljs-number">1</span> + dp[i - c]);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[amount] &gt; amount ? -<span class="hljs-number">1</span> : dp[amount];    &#125;&#125;</code></pre><h2 id="Longest-Palindromic-Subsequence"><a href="#Longest-Palindromic-Subsequence" class="headerlink" title="Longest Palindromic Subsequence"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">Longest Palindromic Subsequence</a></h2><p><img src="https://ae01.alicdn.com/kf/Ue5175d4511fc487b980cb68b68d06af80.jpg"><br>思路： 使用动态规划，每一种子状态中考虑第一个元素和最后一个元素时候相等，相等则这个状态的结果为dp[first+1][last-1]+2，不相等则它俩不可能同时出现在这段字符的最长回文子序列中，比较dp[first][last - 1]和dp[first + 1][last]  </p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">char</span>[] arr = s.toCharArray();        <span class="hljs-keyword">int</span> n = arr.length;        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            dp[i][i] = <span class="hljs-number">1</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;                <span class="hljs-keyword">if</span>(arr[i] == arr[j]) &#123;                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;                &#125;                <span class="hljs-keyword">else</span> &#123;                    dp[i][j] = Math.max(dp[i][j - <span class="hljs-number">1</span>], dp[i + <span class="hljs-number">1</span>][j]);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>];    &#125;&#125;</code></pre><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a><a href="https://leetcode-cn.com/problems/sort-colors/">颜色分类</a></h2><p><img src="https://s1.ax1x.com/2020/08/05/ayRD5q.png"><br>思路：左指针 - 0的结束，右指针 - 2的开始，curr左边为1的区域，右边为未知区域。<br>如图将原数组分为全0区域、全2区域，全1区域，未知区域，其中全0和全2就是处理后的区域，全1区域就是不需要的区域。<br><img src="https://s1.ax1x.com/2020/08/05/ayRqMD.png">  </p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> p0 = <span class="hljs-number">0</span>, p2 = nums.length - <span class="hljs-number">1</span>, curr = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(curr &lt;= p2) &#123;            <span class="hljs-keyword">if</span>(nums[curr] == <span class="hljs-number">0</span>) &#123;                exch(nums, curr, p0);                p0++;                curr++;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[curr] == <span class="hljs-number">2</span>) &#123;                exch(nums,curr, p2);                p2--;            &#125;            <span class="hljs-keyword">else</span> &#123;                curr++;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">int</span> temp = nums[a];        nums[a] = nums[b];        nums[b] = temp;    &#125;&#125;</code></pre><h2 id="3sum"><a href="#3sum" class="headerlink" title="3sum"></a><a href="https://www.lintcode.com/problem/3sum/description">3sum</a></h2><p>Description:<br>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.<br><img src="https://s1.ax1x.com/2020/08/04/aD3tRe.png"><br>思路：将问题转化成two sum，把数组排序，定义左右指针和target值，此时numbers[left]+number[right]如果小于target，则只能将左指针右移，反之同理。注意重复值应跳过。  </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> numbers: Give an array numbers of n integer</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: Find all unique triplets in the array which gives the sum of zero.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] numbers) &#123;        <span class="hljs-comment">// write your code here</span>        Arrays.sort(numbers);        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span>(numbers == <span class="hljs-keyword">null</span> || numbers.length &lt; <span class="hljs-number">3</span>) &#123;            <span class="hljs-keyword">return</span> result;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.length - <span class="hljs-number">2</span>; i++) &#123;            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; numbers[i] == numbers[i - <span class="hljs-number">1</span>]) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            twoSum(numbers, i + <span class="hljs-number">1</span>, numbers.length - <span class="hljs-number">1</span>, -numbers[i], result);        &#125;        <span class="hljs-keyword">return</span> result;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] numbers, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> target, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;        <span class="hljs-keyword">int</span> cur = left - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left &lt; right)&#123;            <span class="hljs-keyword">if</span>(numbers[left] + numbers[right] == target) &#123;                List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();                tmp.add(numbers[cur]);                tmp.add(numbers[left]);                tmp.add(numbers[right]);                System.out.println(left + <span class="hljs-string">&quot; &quot;</span> + right);                left++;                right--;                result.add(tmp);                <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; numbers[left] == numbers[left - <span class="hljs-number">1</span>]) &#123;                    left++;                &#125;                <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; numbers[right] == numbers[right + <span class="hljs-number">1</span>]) &#123;                    right--;                &#125;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[left] + numbers[right] &lt; target) &#123;                left++;            &#125;            <span class="hljs-keyword">else</span> &#123;                right--;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">删除排序数组中的重复项</a></h2><p><img src="https://ae01.alicdn.com/kf/U96f43274e3c24a3ebfd61742d6e99a12t.jpg">    </p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">if</span>(nums[i] != nums[i - <span class="hljs-number">1</span>]) &#123;                nums[j] = nums[i];                j++;            &#125;        &#125;        <span class="hljs-keyword">return</span> j;    &#125;&#125;</code></pre><h2 id="删除排序数组中的重复项-II"><a href="#删除排序数组中的重复项-II" class="headerlink" title="删除排序数组中的重复项 II"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/">删除排序数组中的重复项 II</a></h2><p><img src="https://ae01.alicdn.com/kf/U70cdcfcdbfc14df4bd0efc8758dc283f1.jpg"><br>思路：i是遍历指针，指向当前遍历的元素；j指向下一个要覆盖元素的位置  </p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>, count = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">if</span>(nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;                count++;            &#125;            <span class="hljs-keyword">else</span> &#123;                count = <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">if</span>(count &lt;= <span class="hljs-number">2</span>) &#123;                nums[j] = nums[i];                j++;            &#125;        &#125;        <span class="hljs-keyword">return</span> j;    &#125;&#125;</code></pre><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a><a href="https://leetcode-cn.com/problems/daily-temperatures/">每日温度</a></h2><p><img src="https://s1.ax1x.com/2020/08/03/adKrSP.png"><br>解法一：单调栈  </p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dailyTemperatures(<span class="hljs-keyword">int</span>[] T) &#123;        <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[T.length];        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        stack.push(<span class="hljs-number">0</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; T.length; i++) &#123;            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; T[i] &gt; T[stack.peek()]) &#123;                result[stack.peek()] = i - stack.peek();                stack.pop();            &#125;            stack.push(i);        &#125;        <span class="hljs-keyword">while</span>(!stack.isEmpty()) &#123;            result[stack.pop()] = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><p>解法二：从后向前  </p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dailyTemperatures(<span class="hljs-keyword">int</span>[] T) &#123;        <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[T.length];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = T.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            <span class="hljs-keyword">if</span>(T[i] &lt; T[i + <span class="hljs-number">1</span>]) &#123;                result[i] = <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">1</span> + result[i + <span class="hljs-number">1</span>];                <span class="hljs-keyword">while</span>(i + tmp &lt;= T.length - <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">if</span>(T[i] &lt; T[i + tmp]) &#123;                        result[i] = tmp;                        <span class="hljs-keyword">break</span>;                    &#125;                    <span class="hljs-keyword">if</span>(result[i + tmp] == <span class="hljs-number">0</span>) &#123;                        result[i] = <span class="hljs-number">0</span>;                        <span class="hljs-keyword">break</span>;                    &#125;                    tmp += result[i + tmp];                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><h2 id="验证二叉树的前序序列化"><a href="#验证二叉树的前序序列化" class="headerlink" title="验证二叉树的前序序列化"></a><a href="https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/">验证二叉树的前序序列化</a></h2><p><img src="https://ae01.alicdn.com/kf/U86cd96996a794c6d9db882f2ff1317edU.jpg"><br>思路：使用栈，遇到#将栈顶元素减1，遇到数字将栈顶元素减1后再push进2，相当于判断节点的子节点数量；把栈中元素看成一个整体，即所有剩余槽位的数量，可以将空间复杂度降至O(1)</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidSerialization</span><span class="hljs-params">(String preorder)</span> </span>&#123;        String[] arr = preorder.split(<span class="hljs-string">&quot;,&quot;</span>);        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        stack.push(<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;            <span class="hljs-keyword">if</span>(stack.isEmpty()) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-keyword">int</span> head = stack.pop() - <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(head &gt; <span class="hljs-number">0</span>) &#123;                stack.push(head);            &#125;            <span class="hljs-keyword">if</span>(!<span class="hljs-string">&quot;#&quot;</span>.equals(arr[i])) &#123;                stack.push(<span class="hljs-number">2</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> stack.isEmpty();    &#125;&#125;</code></pre><h2 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形</a></h2><p><img src="https://ae01.alicdn.com/kf/U60d86578af774150a41e77c338a401c7l.jpg"><br>思路：找到左侧小于当前元素的位置和右侧小于当前元素的位置  </p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights)</span> </span>&#123;        <span class="hljs-keyword">if</span>(heights.length == <span class="hljs-number">0</span> || heights == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = heights.length;        <span class="hljs-keyword">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-keyword">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= heights[i]) &#123;                stack.pop();            &#125;            <span class="hljs-keyword">if</span>(stack.isEmpty()) &#123;                left[i] = -<span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;                left[i] = stack.peek();            &#125;            stack.push(i);        &#125;        stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= heights[i]) &#123;                stack.pop();            &#125;               <span class="hljs-keyword">if</span>(stack.isEmpty()) &#123;                right[i] = n;            &#125;            <span class="hljs-keyword">else</span> &#123;                right[i] = stack.peek();            &#125;                    stack.push(i);        &#125;        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n - <span class="hljs-number">1</span>; i++) &#123;            max = Math.max(heights[i] * (right[i] - left[i] - <span class="hljs-number">1</span>), max);        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;<span class="hljs-comment">// 减少空间的解法：</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights)</span> </span>&#123;        <span class="hljs-keyword">if</span>(heights.length == <span class="hljs-number">0</span> || heights == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = heights.length;        <span class="hljs-keyword">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-keyword">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        Arrays.fill(right, n);        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= heights[i]) &#123;                right[stack.peek()] = i;                stack.pop();            &#125;            <span class="hljs-keyword">if</span>(stack.isEmpty()) &#123;                left[i] = -<span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;                left[i] = stack.peek();            &#125;            stack.push(i);        &#125;        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n - <span class="hljs-number">1</span>; i++) &#123;            max = Math.max(heights[i] * (right[i] - left[i] - <span class="hljs-number">1</span>), max);        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre><h1 id="BFS-amp-DFS"><a href="#BFS-amp-DFS" class="headerlink" title="BFS &amp; DFS"></a>BFS &amp; DFS</h1><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">全排列</a></h2><p><img src="https://s1.ax1x.com/2020/08/06/aR33Q0.png"><br>思路：回溯法 + DFS，每次递归前将该数字设为used，递归结束后回溯到原来not used的状态  </p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length];        dfs(nums, used, res, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;());        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">boolean</span>[] used, List&lt;List&lt;Integer&gt;&gt; res, <span class="hljs-keyword">int</span> length, ArrayList&lt;Integer&gt; cur_array)</span> </span>&#123;        <span class="hljs-keyword">if</span>(length == nums.length) &#123;            res.add(<span class="hljs-keyword">new</span> ArrayList(cur_array));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">if</span>(!used[i]) &#123;                cur_array.add(nums[i]);                used[i] = <span class="hljs-keyword">true</span>;                dfs(nums, used, res, length + <span class="hljs-number">1</span>, cur_array);                cur_array.remove(cur_array.size() - <span class="hljs-number">1</span>);                used[i] = <span class="hljs-keyword">false</span>;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="重新安排行程"><a href="#重新安排行程" class="headerlink" title="重新安排行程"></a><a href="https://leetcode-cn.com/problems/reconstruct-itinerary/">重新安排行程</a></h2><p><img src="https://s1.ax1x.com/2020/08/27/d5ZTLd.png"><br>思路： 欧拉回路 / 欧拉通路，注意当我们贪心地选择字典序最小的节点前进时，可能先走入「死胡同」<br>使用<em>Hierholzer 算法</em>，逆序入栈  </p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    Map&lt;String, PriorityQueue&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; tickets)</span> </span>&#123;               <span class="hljs-keyword">if</span>(tickets.size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;                <span class="hljs-keyword">for</span>(List&lt;String&gt; l : tickets) &#123;            String src = l.get(<span class="hljs-number">0</span>), dest = l.get(<span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(!map.containsKey(src)) &#123;                map.put(src, <span class="hljs-keyword">new</span> PriorityQueue&lt;String&gt;());            &#125;            map.get(src).add(dest);        &#125;               dfs(<span class="hljs-string">&quot;JFK&quot;</span>);        Collections.reverse(res);        <span class="hljs-keyword">return</span> res;    &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">while</span>(map.containsKey(s) &amp;&amp; !map.get(s).isEmpty()) &#123;            String next = map.get(s).poll();            dfs(next);        &#125;        res.add(s);    &#125;&#125;</code></pre><h1 id="Other-records"><a href="#Other-records" class="headerlink" title="Other records"></a>Other records</h1><h2 id="非递减数列"><a href="#非递减数列" class="headerlink" title="非递减数列"></a><a href="https://leetcode-cn.com/problems/non-decreasing-array/">非递减数列</a></h2><p><img src="https://ae01.alicdn.com/kf/U44b9dbd31bf84558879d2f137d0734afY.jpg"><br>思路： 一道有点迷的简单题，总之就是各种情况都要考虑清楚  </p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkPossibility</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">if</span>(nums[i] &lt; nums[i - <span class="hljs-number">1</span>]) &#123;                cnt++;                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span> || nums[i] &gt;= nums[i - <span class="hljs-number">2</span>]) &#123;                    nums[i - <span class="hljs-number">1</span>] = nums[i];                &#125;                <span class="hljs-keyword">else</span> &#123;                    nums[i] = nums[i - <span class="hljs-number">1</span>];                &#125;            &#125;        &#125;        <span class="hljs-keyword">if</span>(cnt &gt;= <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre><h2 id="LRU-缓存机制"><a href="#LRU-缓存机制" class="headerlink" title="LRU 缓存机制"></a><a href="https://leetcode-cn.com/problems/lru-cache/">LRU 缓存机制</a></h2><p><img src="https://s3.ax1x.com/2021/02/10/y0dYJs.png"><br>思路： LinkedHashMap，key为键值，value为链表中的节点  </p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;    <span class="hljs-keyword">private</span> Map&lt;Integer, DLinkedNode&gt; map;    <span class="hljs-keyword">private</span> DLinkedNode head;    <span class="hljs-keyword">private</span> DLinkedNode tail;    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DLinkedNode</span> </span>&#123;        DLinkedNode prev;        DLinkedNode next;        <span class="hljs-keyword">int</span> key;        <span class="hljs-keyword">int</span> value;        DLinkedNode() &#123;        &#125;        DLinkedNode(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value) &#123;            <span class="hljs-keyword">this</span>.value = value;            <span class="hljs-keyword">this</span>.key = key;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">this</span>.capacity = capacity;        head = <span class="hljs-keyword">new</span> DLinkedNode();        tail = <span class="hljs-keyword">new</span> DLinkedNode();        head.next = tail;        tail.prev = head;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;        <span class="hljs-keyword">if</span>(map.get(key) == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        moveToHead(map.get(key));        <span class="hljs-keyword">return</span> map.get(key).value;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">if</span>(map.get(key) == <span class="hljs-keyword">null</span>) &#123;            size++;            DLinkedNode newNode = <span class="hljs-keyword">new</span> DLinkedNode(key, value);            addToHead(newNode);            map.put(key, newNode);        &#125;        <span class="hljs-keyword">else</span> &#123;            map.get(key).value = value;            moveToHead(map.get(key));        &#125;                <span class="hljs-keyword">if</span>(size &gt; capacity) &#123;            <span class="hljs-keyword">int</span> removeKey = removeTail();            map.put(removeKey, <span class="hljs-keyword">null</span>);            size--;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addToHead</span><span class="hljs-params">(DLinkedNode node)</span> </span>&#123;        node.next = head.next;        head.next.prev = node;        head.next = node;        node.prev = head;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveToHead</span><span class="hljs-params">(DLinkedNode node)</span> </span>&#123;        node.prev.next = node.next;        node.next.prev = node.prev;        addToHead(node);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeTail</span><span class="hljs-params">()</span> </span>&#123;        DLinkedNode removeNode = tail.prev;        tail.prev.prev.next = tail;        tail.prev = tail.prev.prev;        <span class="hljs-keyword">return</span> removeNode.key;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><span class="hljs-comment"> * LRUCache obj = new LRUCache(capacity);</span><span class="hljs-comment"> * int param_1 = obj.get(key);</span><span class="hljs-comment"> * obj.put(key,value);</span><span class="hljs-comment"> */</span></code></pre><h2 id="插入区间"><a href="#插入区间" class="headerlink" title="插入区间"></a><a href="https://leetcode-cn.com/problems/insert-interval/">插入区间</a></h2><p><img src="https://ae01.alicdn.com/kf/Ub680c6b75bc641d1b2d14fea5cdc0a15l.jpg"><br><img src="https://ae01.alicdn.com/kf/U003137da0010459db4a7abadbd3e1364N.jpg"><br>思路： 考虑三种情况即可  </p><pre><code class="java">class Solution &#123;    public int[][] insert(int[][] intervals, int[] newInterval) &#123;        ArrayList&lt;int[]&gt; res = new ArrayList&lt;&gt;();        int len = intervals.length;        int i = 0;        while (i &lt; len &amp;&amp; intervals[i][1] &lt; newInterval[0]) &#123;            res.add(intervals[i]);            i++;        &#125;        while (i &lt; len &amp;&amp; intervals[i][0] &lt;= newInterval[1]) &#123;            newInterval[0] = Math.min(intervals[i][0], newInterval[0]);            newInterval[1] = Math.max(intervals[i][1], newInterval[1]);            i++;        &#125;        res.add(newInterval);        while (i &lt; len &amp;&amp; intervals[i][0] &gt; newInterval[1]) &#123;            res.add(intervals[i]);            i++;        &#125;        return res.toArray(new int[0][]);    &#125;&#125;</code></pre><h2 id="Tree-Iterator-without-using-recursion"><a href="#Tree-Iterator-without-using-recursion" class="headerlink" title="Tree Iterator without using recursion"></a>Tree Iterator without using recursion</h2><pre><code class="java">/** * Definition of TreeNode: * public class TreeNode &#123; *     public int val; *     public TreeNode left, right; *     public TreeNode(int val) &#123; *         this.val = val; *         this.left = this.right = null; *     &#125; * &#125; * Example of iterate a tree: * BSTIterator iterator = new BSTIterator(root); * while (iterator.hasNext()) &#123; *    TreeNode node = iterator.next(); *    do something for node * &#125;  */public class BSTIterator &#123;    private Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();    // @param root: The root of binary tree.    public BSTIterator(TreeNode root) &#123;        while (root != null) &#123;            stack.push(root);            root = root.left;        &#125;    &#125;    //@return: True if there has next node, or false    public boolean hasNext() &#123;        return !stack.isEmpty();    &#125;    //@return: return next node    public TreeNode next() &#123;        TreeNode curt = stack.peek();        TreeNode node = curt;        // move to the next node        if (node.right == null) &#123;            node = stack.pop();            while (!stack.isEmpty() &amp;&amp; stack.peek().right == node) &#123;                node = stack.pop();            &#125;        &#125; else &#123;            node = node.right;            while (node != null) &#123;                stack.push(node);                node = node.left;            &#125;        &#125;        return curt;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决MySQL的encoding问题</title>
    <link href="/2020/04/06/2020-04-06-%E8%A7%A3%E5%86%B3MySQL%E7%9A%84encoding%E9%97%AE%E9%A2%98/"/>
    <url>/2020/04/06/2020-04-06-%E8%A7%A3%E5%86%B3MySQL%E7%9A%84encoding%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>解决MySQL无法正常显示emoji及一些小语种的问题</p></blockquote><a id="more"></a><p>在load数据的时候发现MySQL无法正常显示emoji和日语、阿拉伯语等等的语言，主要原因是没有使用utf8mb4编码，可以通过以下操作解决                                                                                                                                                                                                      </p><ol><li><p>查看当前MySQL的编码，会发现使用的是latin  </p><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">VARIABLES</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%character_set_%&#x27;</span>;</code></pre></li><li><p>改变当前数据的encoding  </p><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">DATABASE</span> &lt;your_database&gt; <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci;</code></pre></li><li><p>修改配置文件 /etc/mysql/mysql.conf.d/mysqld.cnf<br>直接再最后加上：  </p><pre><code class="hljs ini"><span class="hljs-section">[client]</span>  <span class="hljs-attr">default-character-set</span> = utf8mb4  <span class="hljs-section">[mysql]</span>  <span class="hljs-attr">default-character-set</span> = utf8mb4  <span class="hljs-section">[mysqld]</span>  <span class="hljs-attr">character-set-client-handshake</span> = <span class="hljs-literal">FALSE</span>  <span class="hljs-attr">character-set-server</span> = utf8mb4  <span class="hljs-attr">collation-server</span> = utf8mb4_unicode_ci</code></pre></li><li><p>重启MySQL  </p><pre><code class="hljs routeros">sudo<span class="hljs-built_in"> service </span>restart mysql</code></pre></li></ol><p>搞定！最后可以再确定一下encoding，应该会有如下的显示：   </p><p><img src="https://s1.ax1x.com/2020/08/28/dIsNy8.png" alt="Encoding"></p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Cloud Computing笔记</title>
    <link href="/2020/04/05/2020-04-05-%E4%BA%91%E8%AE%A1%E7%AE%97%20Cloud%20Computing/"/>
    <url>/2020/04/05/2020-04-05-%E4%BA%91%E8%AE%A1%E7%AE%97%20Cloud%20Computing/</url>
    
    <content type="html"><![CDATA[<p>主要是15-619（15-319）这节课的内容，我这么懒的人，不一定能完完整整都记下来哈哈哈</p><a id="more"></a>  <p>云计算这课上到现在基本算是结束了，这节课上下来的感觉并没传说中那么恐怖，当然也没有多轻松。<br>确实接触了挺多新的工具和知识，HBase/Spark/Hadoop/MapReduce/Docker/k8s等等等等，最尴尬的是面试的时候会被说学了很多但哪一个都没有深入的研究下去。写写博客总结一下这一学期cc的project，顺便也再学习一遍。</p><h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><p><img src="https://s3.amazonaws.com/cmucc-public/15619public/webcontent/mapReduce_analytics_engine.png" alt="MapReduce"><br>MapReduce由两部分组成，Map Phase和Reduce Phase，Map Phase由一个或多个相同的Map task组成，Reduce Phase则由零个或多个相同的Reduce task组成。<br>Map就是把数据转为Key/Value Pair的形式，Reduce则是完成一个类似于group by的操作。<br>以经典的word count为例：  </p><ul><li>Map task的输入为”the boy ate the apple”  </li><li>Map task的输出为(the, 1), (boy, 1), (ate, 1), (the, 1), (apple, 1)</li><li>经过sort和shuffle stage，具有相同key的intermediate Key/Value pairs将被放入同一个reducer中</li><li>The reduce task will aggregate the counts for the same word </li><li>If you had a single reduce task that is processing all possible keys, then the input will be (the, list(1,1)), (boy, list(1)), (ate, list(1)), (apple, list(1)) and the output will be: (the, 2), (boy, 1), (ate, 1), (apple, 1)<br><img src="https://s1.ax1x.com/2020/08/28/dIsof1.png" alt="MapReduce">   </li></ul><p>在MapReduce中还有一步操作是Combine，Combine使用的方法就是Reduce。我们可以在Map Phase中先对key进行aggregate，如下图：<br><img src="https://s3.amazonaws.com/cmucc-public/15619public/webcontent/p12/map-reduce-combiner.png" alt="MapReduce"> </p><p>需要根据情况判断是否使用Combiner。在word count这个例子中，使用combiner可以提升效率，总体的和是部分和的加总。但如果我们算的是平均值，使用combiner则会导致结果错误，总体的平均并不是部分平均值的平均。</p><h1 id="Docker-amp-k8s"><a href="#Docker-amp-k8s" class="headerlink" title="Docker &amp; k8s"></a>Docker &amp; k8s</h1>]]></content>
    
    
    <categories>
      
      <category>cloudcomputing</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2019年的读书记录</title>
    <link href="/2020/01/07/2020-01-07-2019%E5%B9%B4%E7%9A%84%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/01/07/2020-01-07-2019%E5%B9%B4%E7%9A%84%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>2019年很闲，闲到读了很多书，博客很久没更新过，干脆记录一下去年读过的书好了。年度最爱竟然是！是麻耶雄嵩的《有翼之暗》！</p><a id="more"></a><h2 id="推理部门（有点泄底）"><a href="#推理部门（有点泄底）" class="headerlink" title="推理部门（有点泄底）"></a>推理部门（有点泄底）</h2><h3 id="麻耶雄嵩"><a href="#麻耶雄嵩" class="headerlink" title="麻耶雄嵩"></a>麻耶雄嵩</h3><p>《<a href="https://book.douban.com/subject/11607283/">萤</a>》<br>麻耶雄嵩是个很坑爹的作者。不仔仔细细读这本书的话，99.9%的概率需要读第二遍，性别叙诡真是有点那个，虽然多读几本坑爹的新本格推理会提高警惕，但还是很想骂人：）</p><p>《<a href="https://book.douban.com/subject/25892396/">有翼之暗</a>》<br>我很喜欢的一本书，还是麻耶雄嵩最擅长的崩坏流。古宅、家族秘密、猎奇的连续死亡、神秘的少女，日系推理的要素真是相当完备。解答三次转折，不读到结尾永远得不到真相。</p><p>《<a href="https://book.douban.com/subject/26936111/">神的游戏</a>》<br>开头是快乐的少年侦探团（我真的很喜欢柯南里的少年侦探团，无忧无虑的几个小学生不咋上学天天跟着阿笠博士和毛利shu（三声）shu（二声）满世界乱跑，うらやましい），没想到又又又又是崩坏流，崩坏到仙女座星系了，但有一说一，我还挺喜欢。豆瓣评分8.4，我看是因为读的人很少吧。</p><h3 id="西泽保彦"><a href="#西泽保彦" class="headerlink" title="西泽保彦"></a>西泽保彦</h3><p>《<a href="https://book.douban.com/subject/27078155/">解体诸因</a>》<br>很有趣的小黄书（指书皮是黄色的），几个主题相似的推理短篇。推理最能唬人的一点就是要血腥，最血腥的操作就是分尸，本书探讨了凶手们为什么要分尸的心路历程。</p><p>《<a href="https://book.douban.com/subject/27055125/">死了七次的男人</a>》<br>统称七死男，和《<a href="https://book.douban.com/subject/27078155/">解体诸因</a>》一样算是西泽保彦的代表作了。幻想推理，这个叫法很有意思，尽管我觉得没有很多推理成分，硬说的话也算叙诡吧。西泽保彦这人讲故事太啰嗦，看题目“死了七次”，每次的经历没差太多却一统描写，看到第四五次的时候很想撕书哦。</p><p>《<a href="https://book.douban.com/subject/26373943/">她死去的那一晚</a>》<br>《<a href="https://book.douban.com/subject/27200982/">替身</a>》<br>给我留下的印象不很深的两本，搁一起说了。前一本的手法还算可圈可点，后一本我不是特别喜欢。总的来说就是四人组匠仔、高千、小兔和漂撇学长喝酒聊天推理破案的故事。</p><h3 id="江户川乱步"><a href="#江户川乱步" class="headerlink" title="江户川乱步"></a>江户川乱步</h3><p>《<a href="https://book.douban.com/subject/6558049/">阴兽</a>》<br>《<a href="https://book.douban.com/subject/6558046/">人间椅子</a>》<br>变态推理文学，没了。</p><h3 id="埃勒里·奎因"><a href="#埃勒里·奎因" class="headerlink" title="埃勒里·奎因"></a>埃勒里·奎因</h3><p>《<a href="https://book.douban.com/subject/26915344/">X的悲剧</a>》<br>人名太难记了，还有我希望全世界的侦探可以调查到了什么就直接说出来！</p><p>《<a href="https://book.douban.com/subject/26915345/">Y的悲剧</a>》<br>哲瑞•雷恩真是心狠手辣，审判命运这种事请交给法庭。</p><h3 id="阿加莎·克里斯蒂"><a href="#阿加莎·克里斯蒂" class="headerlink" title="阿加莎·克里斯蒂"></a>阿加莎·克里斯蒂</h3><p>我真的不适合读欧美的推理小说唉。阿婆的书太多了，去年决定读完马普尔小姐系列，结果只读了9本。每本内容不多，在手机上读平均每本也就是400-500页的样子，手法也不复杂，我说是日系推理的饭后甜点吧。总之，马普尔这位老小姐很可爱啊！  </p><h5 id="马普尔小姐系列"><a href="#马普尔小姐系列" class="headerlink" title="马普尔小姐系列"></a>马普尔小姐系列</h5><p>《<a href="https://book.douban.com/subject/21617613/">寓所谜案</a>》<br>马普尔小姐系列的第一本，剧情全忘了，骚凹瑞阿婆。</p><p>《<a href="https://book.douban.com/subject/24358966/">藏书室女尸之谜</a>》<br>大名鼎鼎戈辛顿庄园第一案，很平淡，人还不是在戈辛顿庄园死的。</p><p>《<a href="https://book.douban.com/subject/30245148/">死亡草</a>》<br>目前为止马普尔小姐系列最喜欢的一本，短篇集，说起来我真的很喜欢推理短篇。</p><p>《<a href="https://book.douban.com/subject/25877118/">魔手</a>》<br>剧情全忘了，骚凹瑞阿婆。</p><p>《<a href="https://book.douban.com/subject/25928086/">谋杀启事</a>》<br>这个系列的代表作，身份替换这个手法在《<a href="https://book.douban.com/subject/30245148/">死亡草</a>》用过了，没意思。</p><p>《<a href="https://book.douban.com/subject/26376888/">借镜杀人</a>》<br>剧情全忘了，骚凹瑞阿婆。我看《<a href="https://book.douban.com/subject/25986370/">破镜谋杀案</a>》的时候还认真想了一下这本有没有读过，真是幸亏在豆瓣上标记了。</p><p>《<a href="https://book.douban.com/subject/30174285/">黑麦奇案</a>》<br>童谣杀人第二案！</p><p>《<a href="https://book.douban.com/subject/26253719/">命案目睹记</a>》<br>窗外看见了并排行驶的另一列火车上发生的谋杀案，这个场景有点点吓人。</p><p>《<a href="https://book.douban.com/subject/25986370/">破镜谋杀案</a>》<br>我想阿婆很后悔没有给戈辛顿庄园安排一次”真正的“谋杀案，这一本四个人死在了庄园里，可惜的是阿婆实在不适合写连续杀人案。日本拍过这本的推理SP，黑木瞳演的那位女演员，从此她演什么我都觉得像凶手。</p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>《<a href="https://book.douban.com/subject/21371175/">罗杰疑案</a>》<br>本书的手法搁当时来说是相当新颖，搁现在讲就是烂大街。</p><p>《<a href="https://book.douban.com/subject/25929085/">阳光下的罪恶</a>》<br>在太阳底下，到处都有邪恶的事。</p><p>《<a href="https://book.douban.com/subject/25835911/">幸福假面</a>》<br>这本不是推理小说，而且我超级不喜欢，阿婆这个”心之罪“系列我或许不会再读了。我读完的感受就是疑惑这可能是英国女德教育。</p><h3 id="其他作者"><a href="#其他作者" class="headerlink" title="其他作者"></a>其他作者</h3><p>乙一 —— 《<a href="https://book.douban.com/subject/34778574/">夏天、烟火和我的尸体</a>》<br>我想江户川乱步后继有人了，够变态，够吓人，小朋友就很恐怖了，小朋友干谋杀抛尸这种事还有没有辙了。</p><p>冈岛二人 —— 《<a href="https://book.douban.com/subject/33658616/">克莱因壶</a>》<br>就是《盗梦空间》那套，但一看是1989年的书，惊到了，那可够牛逼的。</p><p>岛田庄司 —— 《<a href="https://book.douban.com/subject/10740772/">斜屋犯罪</a>》<br>2019年才读岛田老师的这本书，罪过！前言讲得挺好，“一间密室之内，有人死于非命，凶手人间蒸发，此为本格派；有人死于非命，凶手人间蒸发，并在尸体四周建密室一间，此谓新本格派”。</p><h2 id="非推理部门"><a href="#非推理部门" class="headerlink" title="非推理部门"></a>非推理部门</h2><h3 id="那不勒斯四部曲"><a href="#那不勒斯四部曲" class="headerlink" title="那不勒斯四部曲"></a>那不勒斯四部曲</h3><p>埃莱娜·费兰特 —— 《<a href="https://book.douban.com/subject/26878124/">我的天才女友</a>》 《<a href="https://book.douban.com/subject/27104959/">新名字的故事</a>》 《<a href="https://book.douban.com/subject/27104959/">离开的，留下的</a>》 《<a href="https://book.douban.com/subject/30172069/">失踪的孩子</a>》<br>因为被拍成了剧，这套书前几年真是名声大噪，我慕名去读了，读的时候只有俩字儿——生气！女主莱农对于爱情很没脑子，我十分读不懂这个角色。男主（？）尼诺则是一位绝世大渣男，说着厌恶父亲的多情，自己却已经成为了父亲那样的人。之前看ARASHI那部《<a href="https://movie.douban.com/subject/25905892/">生活艰难也许快乐</a>》，年轻的我们也是看着船上喝酒的社畜和朋友说着绝对不会成为这样的人，最终却还是一起上了那艘船，变成了最讨厌的那种大人。<br>说回来四本书的中心思想还是莱农和莉拉一生的友情，莉拉那句 “但你不一样，你是我的天才朋友，你应该比任何人都要厉害，无论是男生还是女生” 让我有点点感动，真的是完完整整地写完了一生啊。</p><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><p>三浦紫苑 —— 《<a href="https://book.douban.com/subject/26210487/">强风吹拂</a>》<br>“教练，我想要跑步！”</p>]]></content>
    
    
    <categories>
      
      <category>reading</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Sorting Algorithms</title>
    <link href="/2019/10/06/2019-10-06-Sorting-Algorithms/"/>
    <url>/2019/10/06/2019-10-06-Sorting-Algorithms/</url>
    
    <content type="html"><![CDATA[<p>📙 MY NOTEBOOK FOR <a href="https://www.coursera.org/learn/algorithms-part1/home/welcome">Algorithms - Princeton</a>                                                                                             </p><a id="more"></a><p>👾 You need to add <a href="https://algs4.cs.princeton.edu/code/algs4.jar">algs4.jar</a> to your library to compile the codes. </p><h1 id="Useful-Sorting-Functions"><a href="#Useful-Sorting-Functions" class="headerlink" title="Useful Sorting Functions"></a>Useful Sorting Functions</h1><p><strong>Less</strong>: Is item v less than w?  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">less</span><span class="hljs-params">(Comparable v, Comparable w)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> v.compareTo(w) &lt; <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>Exchange</strong>: Swap item in array a[] at index i with the one at index j.  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exch</span><span class="hljs-params">(Comparable[] a, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span>  <span class="hljs-comment">// NOTICE: the type of the array is Comparable.</span></span><span class="hljs-function"></span>&#123;Comparable swap = a[i];a[i] = a[j];a[j] = a[i];&#125;</code></pre><h1 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a>Selection Sort</h1><p>That’s so easy. You just need to scan from the begining to the end and find the smallest item, exchange them and do it again and again and again. A little bit boring…😅<br>Selection sort uses (N-1) + (N-2) + … + 1 + 0 ~ <strong>N^2 / 2</strong> compares and <strong>N</strong> exchanges.  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> N = a.length;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)&#123;<span class="hljs-keyword">int</span> min = i;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; N; j++)&#123;<span class="hljs-keyword">if</span>(less(a[j], a[min]) min = j;&#125;exch(a, i, min);&#125;&#125;</code></pre><h1 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h1><p>Well, that’s also easy…😀  </p><p>But you must know insertion sort performs well when the array is nearly sorted. In insertion sort, we just have to make sure that the part we have already scanned is sorted, the rest part we don’t care.<br>So in iteration i, as long as a[i] is smaller than its left, we swap it and its left item until it is no less then its left.  </p><p>On average, insertion sort uses ~1/4N^2 compares and ~1/4N^2 exchanges. In the worst case, insertion sort uses ~1/2N^2 compares and ~1/2N^2 exchanges. But for <strong>partially sorted arrays</strong>, insertion sort runs in linear time.<br>😅 Sorry I always don’t know how to calculate the average situation, I prefer to use Big-O. And both selection sort and insertion sort are O(n^2).   </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> N = a.length;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N - <span class="hljs-number">1</span>; i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i; j &gt; <span class="hljs-number">0</span>; j--)&#123;<span class="hljs-keyword">if</span>(less(a[j], a[j -<span class="hljs-number">1</span>])exch(a, j, j - <span class="hljs-number">1</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;&#125;&#125;&#125;</code></pre><h3 id="Improvement-Shell-Sort"><a href="#Improvement-Shell-Sort" class="headerlink" title="Improvement: Shell Sort"></a>Improvement: Shell Sort</h3><p>Why not make our array partially sorted and than use insertion sort?<br>🤔Shellsort: h-sort array for decreasing sequence of values of h.<br><img src="https://s1.ax1x.com/2020/08/28/dIywjK.png" alt="3-sorting">  </p><p>Which increment sequence to use?  <strong>3x + 1</strong> (1, 4, 13, 40, 121, 364, …)  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> N = a.length;<span class="hljs-keyword">int</span> h = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(h &lt; N / <span class="hljs-number">3</span>) h = <span class="hljs-number">3</span> * h + <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(h &gt;= <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h; i &lt; N; i++)&#123;<span class="hljs-keyword">int</span> j = i;<span class="hljs-keyword">while</span>(j &gt;= h &amp;&amp; less(a[j], a[j - h]) exch(a, j, j - h);j -= h;<span class="hljs-comment">// for(int j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]) ; j-=h) exch(a, j, j - h);</span>&#125;h = h / <span class="hljs-number">3</span>;  <span class="hljs-comment">// When h = 1, it&#x27;s insertion sort.</span>&#125;&#125;</code></pre><p>The worst-case number of compares used by shellsort with 3x+1 increment is <strong>O( N^(3/2) )</strong></p><h1 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h1><p>As its name, there are two steps in the merge sort (omg, just TWO steps) - merge and sort.  </p><h3 id="STEP-ONE-Merge"><a href="#STEP-ONE-Merge" class="headerlink" title="STEP ONE: Merge"></a>STEP ONE: Merge</h3><p>Consider this question, when there are two already sorted array, assigned a[i] and b[j], and we want to sort them into one big array. This is a simple question, you need two pointers and find which pointer is pointed to a smaller item, select this element and add this pointer. And also, we need extra space to store that element.<br>Now consider the same question in one single array.<br><img src="https://s1.ax1x.com/2020/08/28/dIyDBD.png" alt="enter description here"><br>We need to sort these two parts and get a full-sorted array. Given two sorted subarrays a[lo] to a[mid] and a[mid+1] to a[hi], replace with sorted subarray a[lo] to a[hi]. This is <strong>merge</strong>.  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(Comparable[] a, Comparable[] aux, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> hi)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = lo; k &lt;= hi; k++)&#123;aux[k] = a[k];&#125;<span class="hljs-keyword">int</span> i = lo, j = mid + <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = lo; k &lt;= hi; k++)&#123;<span class="hljs-keyword">if</span>(i &gt; mid) a[k] = a[j++];  <span class="hljs-comment">// When all the items in the left part have been added to the final array.</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j &gt; hi) a[k] = a[i++]; <span class="hljs-comment">// When all the items in the right part have been added to the final array.</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(less(aux[i], aux[j]) a[k] = a[i++];<span class="hljs-keyword">else</span> a[k] = a[j++];&#125;&#125;</code></pre><h3 id="STEP-TWO-Sort"><a href="#STEP-TWO-Sort" class="headerlink" title="STEP TWO: Sort"></a>STEP TWO: Sort</h3><p><img src="https://www.smbc-comics.com/comics/1562409923-20190706.png" alt="Recursion"><br>Merge sort uses recursion and I’m really not good at recursion😣.</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a, Comparable[] aux, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span></span>&#123;<span class="hljs-keyword">if</span>(lo == hi) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">int</span> mid = lo + (hi - lo) / <span class="hljs-number">2</span>;sort(a, aux, lo, mid);sort(a, aux, mid + <span class="hljs-number">1</span>, hi);merge(a, aux, lo, mid, hi);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a)</span></span><span class="hljs-function"></span>&#123;Comparable[] aux = <span class="hljs-keyword">new</span> Comparable[a.length];  <span class="hljs-comment">// You don&#x27;t have to initialize aux each time.</span>sort(a, aux, <span class="hljs-number">0</span>, a.length - <span class="hljs-number">1</span>);&#125;</code></pre><h3 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h3><p>Merge sort uses at most NlgN compares and extra sapce proportional to N.</p><ol><li>Use insertion sort for small subarrays. Cutoff to insertion sort for ~7 items.</li><li>Stop if already sorted. Is biggest item in first half &lt;= smallest item in second half?</li><li>Eliminate the copy to the auxiliary array. Save time, not space. Switching the role of the input and auxiliary array in each recursive call.</li></ol><h3 id="No-recursive-Bottom-up-mergesort"><a href="#No-recursive-Bottom-up-mergesort" class="headerlink" title="No recursive?  Bottom-up mergesort"></a>No recursive?  Bottom-up mergesort</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> N = a.length;Comparable[] a = <span class="hljs-keyword">new</span> Comparable[a.length];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> sz = <span class="hljs-number">1</span>; sz &lt; N; sz = sz + sz)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>; lo &lt; N - sz + <span class="hljs-number">1</span>; lo += sz)&#123;merge(a, aux, lo, lo + sz - <span class="hljs-number">1</span>, Math.min(lo + sz + sz - <span class="hljs-number">1</span>, N-<span class="hljs-number">1</span>));&#125;&#125;&#125;</code></pre><h1 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h1><h3 id="STEP-ONE-Shuffle-the-array"><a href="#STEP-ONE-Shuffle-the-array" class="headerlink" title="STEP ONE:  Shuffle the array"></a>STEP ONE:  Shuffle the array</h3><p><img src="https://s1.ax1x.com/2020/08/28/dIyc4A.png"><br>Make the array randomly sorted. For instance, if the array is increased, it would be inefficient, patitioning doesn’t do anything. Why not use insertion sort in this case?  </p><p>*<strong>Knuth Shuffle</strong>: In iteration i, pick integer r between 0 and i uniformly at random.*</p><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shuffle</span><span class="hljs-params">(Obeject[] a)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> N = a.length;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)&#123;<span class="hljs-keyword">int</span> r = StdRandom.uniform(i + <span class="hljs-number">1</span>);   <span class="hljs-comment">// Generate random number rom the beginning to current location. NOTICE: not from 0 to N-1, but from i to N-1 is OK.</span>exch(a, i , r);&#125;&#125;</code></pre><h3 id="STEP-TWO-Partition"><a href="#STEP-TWO-Partition" class="headerlink" title="STEP TWO:  Partition"></a>STEP TWO:  Partition</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(Comparable[] a, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> i = lo, j = hi + <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<span class="hljs-keyword">while</span>(less(a[++i], a[lo]))<span class="hljs-keyword">if</span>(i == hi) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">while</span>(less(a[lo], a[--j]))<span class="hljs-keyword">if</span>(j == lo) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">if</span>(i &gt;= j) <span class="hljs-keyword">break</span>;exch(a, i , j);&#125;exch(a, lo, j);<span class="hljs-keyword">return</span> j;&#125;</code></pre><h3 id="STEP-THREE-Sort"><a href="#STEP-THREE-Sort" class="headerlink" title="STEP THREE:  Sort"></a>STEP THREE:  Sort</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(hi &lt;= lo) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">//So we can see if there is one element in this time of sorting, it will straightly return, this helps improve efficiency. </span><span class="hljs-keyword">int</span> j = partition(a, lo, hi);sort(a, lo, j - <span class="hljs-number">1</span>);  <span class="hljs-comment">//Recursion</span>sort(a, j + <span class="hljs-number">1</span>, hi);&#125;</code></pre><h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p><img src="https://s1.ax1x.com/2020/08/28/dIyH4s.png">  </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quick</span></span><span class="hljs-class"></span>&#123;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(Comparable[] a, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span></span><span class="hljs-function"></span>&#123;......&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span></span><span class="hljs-function"></span>&#123;......&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a)</span>  <span class="hljs-comment">//Overload</span></span><span class="hljs-function"></span>&#123;StdRandom.shuffle(a);sort(a, <span class="hljs-number">0</span>, a.length - <span class="hljs-number">1</span>);&#125;&#125;</code></pre><h3 id="Improvement-3-way-quicksort"><a href="#Improvement-3-way-quicksort" class="headerlink" title="Improvement : 3-way quicksort"></a>Improvement : 3-way quicksort</h3><p>When there are lots of duplicate elements in the array, using quick sort is not efficient.<br>😈 <strong>~1/2N^2 compares when all keys are equal.</strong> Since each time, the partition doesn’t work and you have to iterate the other side. Using Dijkstra’s 3-way partitioning.  </p><p><em>Dutch national flag problem</em>: <a href="https://en.wikipedia.org/wiki/Dutch_national_flag_problem">https://en.wikipedia.org/wiki/Dutch_national_flag_problem</a><br>😀 <strong>N*lgN when all distinct.</strong>   </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(hi &lt;= lo) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">int</span> lt = lo, gt = hi;Comparable v = a[lo];<span class="hljs-keyword">int</span> i = lo;<span class="hljs-keyword">while</span>(i &lt;= gt)&#123;<span class="hljs-keyword">int</span> cmp = a[i].compareTo(v);<span class="hljs-keyword">if</span>(cmp &lt; <span class="hljs-number">0</span>) exch(a, lt++, i++);  <span class="hljs-comment">// a[i] &lt; v, exchange a[lt] with a[i], increment both lt and i</span><span class="hljs-keyword">if</span>(cmp &gt; <span class="hljs-number">0</span>) exch(a, i, gt--);  <span class="hljs-comment">// a[i] &gt; v, exchange a[gt] with a[i], decrement gt</span><span class="hljs-keyword">else</span> i++;  <span class="hljs-comment">// increment i</span>&#125;sort(a, lo, lt - <span class="hljs-number">1</span>);sort(a, gt + <span class="hljs-number">1</span>, hi);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>algorithms</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
