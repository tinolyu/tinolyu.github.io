<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2020年的读书总结</title>
    <link href="/2020/08/22/2020-05-06-2020%E5%B9%B4%E7%9A%84%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    <url>/2020/08/22/2020-05-06-2020%E5%B9%B4%E7%9A%84%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>感谢微信读书！感谢新星出版社！多读书，读好书！2020年小吕依旧毫无创意地热爱着有点枯燥无聊的推理小说📚</p></blockquote><a id="more"></a><p>写这个博客的时候2020年上半场就要结束了，呆在隔离的酒店里不知道做些什么。这几个月过得很忙乱，Cloud Computing的project，实习的笔试面试，学不会的finance和economy，COVID-19，搁浅的日本之旅，事事难过事事过吧，只能这样安慰自己了。结果就是书没怎么读，写了一堆废话来找借口，隐瞒本人精神世界的空虚。<br>趁着在隔离，多读几本书，分享一下我的（没有任何意义的）感受，边读边写吧！反正也不会有人看的：）  </p><p><em>感谢微信读书！感谢新星出版社！有泄底！！！！泄底！！！泄底！！！</em>    </p><h2 id="《刺青杀人事件》"><a href="#《刺青杀人事件》" class="headerlink" title="《刺青杀人事件》"></a>《<a href="https://book.douban.com/subject/10518843/">刺青杀人事件</a>》</h2><p>为什么会读这本书呢，因为去年我心血来潮在左右胳膊文了两个图案。日本的刺青和普通的文身倒是不大一样，被叫做入れ墨，多见于黑社会成员的后背。这本推理的刺青更像一种艺术，是可以美到让人裱起来欣赏的杰作（当然是从死者身上扒去皮）。<br>密室杀人+身份调换，动过文身念头的人可能都会想到这种手法，有点乏味，但刺青图案背后的神话故事让这本书变得有点玄乎，蛮喜欢哈哈哈。  </p><h2 id="《虹の歯ブラシ-上木らいち発散》"><a href="#《虹の歯ブラシ-上木らいち発散》" class="headerlink" title="《虹の歯ブラシ 上木らいち発散》"></a>《<a href="https://book.douban.com/subject/26285818/">虹の歯ブラシ 上木らいち発散</a>》</h2><p>这本书是绝对的年度最佳（虽然今年刚过去不到一半）！！！！！！！我找不到更🐂🍺的词汇去形容它，读完后我心情激动，久久不能平复！早坂吝是天才啊。<br>是色情小说吗？那可不合格，不够工口。是推理小说吗？并没有华丽的杀人手法，没有构造复杂的建筑物，甚至几篇根本没有杀人事件。<br>青は海とマニキュアの色 这一篇，是我看过的最强的叙诡，赤は上木らいち自身の色 这一篇则简直是作者的炫技了。<br>读它！<br>【txt下载】豆瓣民翻：<a href="https://uploadpicuse.blob.core.windows.net/pictures/%E5%BD%A9%E8%99%B9%E7%89%99%E5%88%B7.txt">https://uploadpicuse.blob.core.windows.net/pictures/彩虹牙刷.txt</a><br>（机智地上传到了Azure blob）    </p><h2 id="《尸人庄谜案》"><a href="#《尸人庄谜案》" class="headerlink" title="《尸人庄谜案》"></a>《<a href="https://book.douban.com/subject/30396712/">尸人庄谜案</a>》</h2><p>因为神木DD演了电影版，我便慕名去看了原作小说。人设简直就是轻小说系，天才美少女侦探这种角色都出现了，竟然还不动画化？！故事背景确实很吸引人，生化危机环境下的推理小说，属于可以一口气读下去地那种类型。但这个手法呢，就一般吧，作为出道作蛮强的。</p><h2 id="《我们盗走星座的理由》"><a href="#《我们盗走星座的理由》" class="headerlink" title="《我们盗走星座的理由》"></a>《<a href="https://book.douban.com/subject/34860553/">我们盗走星座的理由</a>》</h2><p>这书名，多文艺，多清新，多有内涵！《相思病》还算ok，《妖精的学校》没读懂，看了这个<a href="https://book.douban.com/review/12156015/">科普</a>，还是不懂，《骗子绅士》完全没印象了，《终焉童话》有点魔幻的推理，《我们盗走星座的理由》里的小男孩真的太会了，学习了。  </p><h2 id="《斬首循環》"><a href="#《斬首循環》" class="headerlink" title="《斬首循環》"></a>《<a href="https://book.douban.com/subject/1794287/">斬首循環</a>》</h2><p> 时隔多年又一次读了西尾维新老师的书，这本是真·轻小说，手法很没劲，登场角色一个个的全是人设鲜明的美少女搭配一个废柴(?)男主，唉！怎么硕呢，我已经过了犯中二病的年纪了！  </p><h2 id="《推理竞技场》"><a href="#《推理竞技场》" class="headerlink" title="《推理竞技场》"></a>《<a href="https://book.douban.com/subject/30428949/">推理竞技场</a>》</h2><p>这本蛮有趣的，读完基本知道了推理小说的种种套路，N层反转，说起来我真的很喜欢有剧情反转的推理小说，虽然是伪解答，但能编出那么多伪解答也是辛苦作者了。<br>（结尾的真解答超展开是来搞笑的吗）  </p><h2 id="《醉步男》"><a href="#《醉步男》" class="headerlink" title="《醉步男》"></a>《<a href="https://book.douban.com/subject/30359030/">醉步男</a>》</h2><p>今年到目前读的唯一一本科幻小说，时间旅行那套，年纪大了不喜欢读费脑子的书，跳来跳去了，最后女主是个啥我也没读懂，唉！<br>附了一个恐怖小短篇《玩具修理者》，我蛮喜欢，有乙一内味儿了，够变态，够魔幻的。  </p><h2 id="《非人类》"><a href="#《非人类》" class="headerlink" title="《非人类》"></a>《<a href="https://book.douban.com/subject/33476138/">非人类</a>》</h2><p>绫辻行人的短篇集，很没劲，非常没劲，这就是没被收录的原因吧，没有一个有意思的故事。  </p><h2 id="《赤朽叶家的传说》"><a href="#《赤朽叶家的传说》" class="headerlink" title="《赤朽叶家的传说》"></a>《<a href="https://book.douban.com/subject/20440568/">赤朽叶家的传说</a>》</h2><p>难得读了一本纸质书，在从阿德莱德飞厦门的航班上看了一大半。以为是推理小说才开始读的，然后发现推理的情节只在最后10%。书不厚，但写了赤朽叶家的女人三个世代的故事，千里眼万叶，不良少女漫画家毛毬和普通的“我”。<br>去年去熊野古道徒步的时候感觉自己真实地沉浸在一种神秘的神话氛围里，我想赤朽叶家也应该是建在那样的地方。说起出云国啊，日本神话啊，我超超超超级感兴趣。    </p><h2 id="《水母不会冻结》"><a href="#《水母不会冻结》" class="headerlink" title="《水母不会冻结》"></a>《<a href="https://book.douban.com/subject/32494889/">水母不会冻结</a>》</h2><p>书名真是莫名其妙的。看到有人把这本书和绫辻行人的《十角馆事件》对比，那差得可不是一星半点，《十角馆》不管是华丽程度还是手法设计都比《水母》强n个level，我对欧美人名有阅读障碍也是一点，拜托日系推理别搞欧美人设了好不好！！！  </p><h2 id="《独眼少女》"><a href="#《独眼少女》" class="headerlink" title="《独眼少女》"></a>《<a href="https://book.douban.com/subject/25918073/">独眼少女</a>》</h2><p>去年读了好几本麻神的书，今年刚刚读了这一本。还还还还还是麻神最上手的崩坏流，反转反转反转，为了反转而反转，刚刚看到20%的进度就有解答，这能是真解答吗我说，推理也太随意了。女主：凶手是你 -&gt; 不对凶手其实是她 -&gt; 没想到吧其实是他 -&gt; 真正的凶手其实是我啦傻孩子，男主：种田静马-&gt;缩写就是种马了！-&gt;没有感情的生殖机器。男主很惨，栖苅一家更惨。</p>]]></content>
    
    
    <categories>
      
      <category>reading</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Minesweeper Game Design</title>
    <link href="/2020/08/22/2020-08-22-Minesweeper-Game-Design/"/>
    <url>/2020/08/22/2020-08-22-Minesweeper-Game-Design/</url>
    
    <content type="html"><![CDATA[<blockquote><p>人生苦短，我玩扫雷</p></blockquote><a id="more"></a><p>小吕很爱玩儿游戏，这些年来，3a大作玩过不少，有口碑的独立游戏也有过接触，但唯一始终无法放弃的只有扫雷。2019年10月的某天，我在微博痛心疾首的写下下文：  </p><blockquote><p>2017年的冬天，那时的我没有24小时热水的家，不会继承多态，for循环可以看一天，日子很简单。C++期末前夜，我在对外经济贸易大学西门外的咖啡陪你下载了windows应用商店的扫雷，并在6个小时后第一次通关了扫雷（耗时800秒），虽然C++题库还差63885道题没有看。从那天起，我玩啊玩啊，在中级微观经济学课上，在金融风险管理课上，在数据结构课上，我玩花了眼，玩坏了手，玩掉了发，但我就是…不能……停…下…来，越焦虑我就越想扫，越扫我就越焦虑，越焦虑越扫，越扫越焦虑……在异国他乡，我又一次深刻地忏悔，我告诉自己，也告诉别人：年纪轻轻的，别碰扫雷。    </p></blockquote><p>很凑巧，今天在leetcode上偶遇一道关于<a href="https://leetcode-cn.com/problems/minesweeper/">扫雷的题目</a>，dfs算法已经摆这儿了，我想这是个机会自己想想做出来一个属于自己的扫雷游戏。<br>先把题解写这儿：  </p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span>[][] updateBoard(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span>[] click) &#123;        <span class="hljs-keyword">int</span> x = click[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> y = click[<span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span>(board[x][y] == <span class="hljs-string">&#x27;M&#x27;</span>) &#123;            board[x][y] = <span class="hljs-string">&#x27;X&#x27;</span>;            <span class="hljs-keyword">return</span> board;        &#125;        dfs(board, click[<span class="hljs-number">0</span>], click[<span class="hljs-number">1</span>]);        <span class="hljs-keyword">return</span> board;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] x_mov = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;        <span class="hljs-keyword">int</span>[] y_mov = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;            <span class="hljs-keyword">if</span>(isInside(board, x + x_mov[i], y + y_mov[i])) &#123;                <span class="hljs-keyword">if</span>(board[x + x_mov[i]][y + y_mov[i]] == <span class="hljs-string">&#x27;M&#x27;</span>) &#123;                    count++;                &#125;            &#125;        &#125;        <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>) &#123;            board[x][y] = <span class="hljs-string">&#x27;B&#x27;</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;                <span class="hljs-keyword">if</span>(isInside(board, x + x_mov[i], y + y_mov[i]) &amp;&amp; board[x + x_mov[i]][y + y_mov[i]] == <span class="hljs-string">&#x27;E&#x27;</span>) &#123;                    dfs(board, x + x_mov[i], y + y_mov[i]);                &#125;            &#125;        &#125;        <span class="hljs-keyword">else</span> &#123;            board[x][y] = (<span class="hljs-keyword">char</span>)(count + <span class="hljs-string">&#x27;0&#x27;</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isInside</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; board.length &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; board[<span class="hljs-number">0</span>].length;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>game</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>刷题记录</title>
    <link href="/2020/04/11/2020-04-11-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/04/11/2020-04-11-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>主要在这里记录一下自己刷到的一些有点疑惑的题，来自leetcode和lintcode。目前有分治法&amp;遍历、动态规划、双指针、BFS &amp; DFS等类型的题目记录在案！小吕啊小吕，就你这水平，还不多刷点题！</p></blockquote><a id="more"></a><h1 id="分治法-amp-遍历"><a href="#分治法-amp-遍历" class="headerlink" title="分治法&amp;遍历"></a>分治法&amp;遍历</h1><h2 id="Lowest-Common-Ancestor-III"><a href="#Lowest-Common-Ancestor-III" class="headerlink" title="Lowest Common Ancestor III"></a><a href="https://www.lintcode.com/problem/lowest-common-ancestor-iii/description">Lowest Common Ancestor III</a></h2><p>Description:<br>Given the root and two nodes in a Binary Tree. Find the lowest common ancestor(LCA) of the two nodes.<br>The lowest common ancestor is the node with largest depth which is the ancestor of both nodes.<br>Notice:<br>node A or node B may not exist in tree.<br>Each node has a different value<br>Return null if LCA does not exist.<br><img src="https://s1.ax1x.com/2020/08/04/aD1Tvd.png"><br><img src="https://s1.ax1x.com/2020/08/04/aD1xPS.png">  </p><p>思路：把需要的东西都放在return里，建立一个新的returnType类。<br>1.如果右子树和左子树都有要找的值，返回根节点。<br>2.如果仅左子树/右子树有要找的值，则结果在左子树/右子树中。<br>需要额外注意root即为a或b的情况，同时要判断a/b是否存在。  </p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition of TreeNode:</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     public int val;</span><span class="hljs-comment"> *     public TreeNode left, right;</span><span class="hljs-comment"> *     public TreeNode(int val) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = this.right = null;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">returnType</span> </span>&#123;    <span class="hljs-keyword">boolean</span> a_exist;    <span class="hljs-keyword">boolean</span> b_exist;    TreeNode node;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">returnType</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> a_exist, <span class="hljs-keyword">boolean</span> b_exist, TreeNode node)</span> </span>&#123;        <span class="hljs-keyword">this</span>.a_exist = a_exist;        <span class="hljs-keyword">this</span>.b_exist = b_exist;        <span class="hljs-keyword">this</span>.node = node;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">     * @param root: The root of the binary tree.</span><span class="hljs-comment">     * @param A: A TreeNode</span><span class="hljs-comment">     * @param B: A TreeNode</span><span class="hljs-comment">     * @return: Return the LCA of the two nodes.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor3</span><span class="hljs-params">(TreeNode root, TreeNode A, TreeNode B)</span> </span>&#123;        <span class="hljs-comment">// write your code here</span>        returnType r = helper(root, A.val, B.val);        <span class="hljs-keyword">if</span>(r.a_exist &amp;&amp; r.b_exist) &#123;            <span class="hljs-keyword">return</span> r.node;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> returnType <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode node, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> returnType(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);        &#125;        returnType left_part = helper(node.left, a, b);        returnType right_part = helper(node.right, a, b);                <span class="hljs-keyword">boolean</span> a_exist = left_part.a_exist || right_part.a_exist || node.val == a;        <span class="hljs-keyword">boolean</span> b_exist = left_part.b_exist || right_part.b_exist || node.val == b;                <span class="hljs-keyword">if</span>(node.val == a || node.val == b) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> returnType(a_exist, b_exist, node);        &#125;        <span class="hljs-keyword">if</span>(left_part.node != <span class="hljs-keyword">null</span> &amp;&amp; right_part.node != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> returnType(a_exist, b_exist, node);        &#125;        <span class="hljs-keyword">if</span>(left_part.node != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> returnType(a_exist, b_exist, left_part.node);        &#125;        <span class="hljs-keyword">if</span>(right_part.node != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> returnType(a_exist, b_exist, right_part.node);        &#125;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> returnType(a_exist, b_exist, <span class="hljs-keyword">null</span>);    &#125;&#125;</code></pre><h2 id="Kth-Smallest-Element-in-a-BST"><a href="#Kth-Smallest-Element-in-a-BST" class="headerlink" title="Kth Smallest Element in a BST"></a><a href="https://www.lintcode.com/problem/kth-smallest-element-in-a-bst/description">Kth Smallest Element in a BST</a></h2><p>Description:<br>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.<br>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.<br><img src="https://s1.ax1x.com/2020/08/04/aD3pvj.png">  </p><p>思路：BST中，左子树的值比右子树小。遍历BST，存入每一个subtree的node数，判断左子树的node数/左子树的node数+1和k的关系。  </p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition of TreeNode:</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     public int val;</span><span class="hljs-comment"> *     public TreeNode left, right;</span><span class="hljs-comment"> *     public TreeNode(int val) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = this.right = null;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root: the given BST</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> k: the given k</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: the kth smallest element in BST</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-comment">// write your code here</span>        HashMap&lt;TreeNode, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt; ();        getNumNode(root, map);        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">if</span>(map.get(root.left) &gt;= k) &#123;            <span class="hljs-keyword">return</span> kthSmallest(root.left, k);        &#125;        <span class="hljs-keyword">if</span>(map.get(root.left) + <span class="hljs-number">1</span> == k) &#123;            <span class="hljs-keyword">return</span> root.val;        &#125;        <span class="hljs-keyword">return</span> kthSmallest(root.right, k - map.get(root.left) - <span class="hljs-number">1</span>);    &#125;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumNode</span><span class="hljs-params">(TreeNode root, HashMap&lt;TreeNode, Integer&gt; map)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) &#123;            map.put(root, <span class="hljs-number">0</span>);            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;         <span class="hljs-keyword">int</span> left = getNumNode(root.left, map);        <span class="hljs-keyword">int</span> right = getNumNode(root.right, map);        <span class="hljs-keyword">if</span>(!map.containsKey(root)) map.put(root, left + right+ <span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> left + right+ <span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h2 id="Validate-Binary-Search-Tree"><a href="#Validate-Binary-Search-Tree" class="headerlink" title="Validate Binary Search Tree"></a><a href="https://www.lintcode.com/problem/validate-binary-search-tree/description">Validate Binary Search Tree</a></h2><p>Description:<br>Given a binary tree, determine if it is a valid binary search tree (BST).<br>Assume a BST is defined as follows:<br>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.<br>A single node tree is a BST<br><img src="https://s1.ax1x.com/2020/08/04/aD3KM9.png"><br>思路：（分治法）判断BST需要判断左子树和右子树是否均为BST，且左子树的最大值&lt;root.val&lt;右子树的最小值，为了记录subtree的最小值和最大值，需要建立一个returnType存放这些信息。   </p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition of TreeNode:</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     public int val;</span><span class="hljs-comment"> *     public TreeNode left, right;</span><span class="hljs-comment"> *     public TreeNode(int val) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = this.right = null;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">returnType</span> </span>&#123;    <span class="hljs-keyword">int</span> maxV;    <span class="hljs-keyword">int</span> minV;    <span class="hljs-keyword">boolean</span> isValid;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">returnType</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxV, <span class="hljs-keyword">int</span> minV, <span class="hljs-keyword">boolean</span> isValid)</span> </span>&#123;        <span class="hljs-keyword">this</span>.maxV = maxV;        <span class="hljs-keyword">this</span>.minV = minV;        <span class="hljs-keyword">this</span>.isValid = isValid;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root: The root of binary tree.</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: True if the binary tree is BST, or false</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-comment">// write your code here</span>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">return</span> helper(root).isValid;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> returnType <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> returnType(root.val, root.val, <span class="hljs-keyword">true</span>);        &#125;                <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span>) &#123;            returnType right_part = helper(root.right);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> returnType(right_part.maxV, root.val, root.val &lt; right_part.minV &amp;&amp; right_part.isValid);        &#125;        <span class="hljs-keyword">if</span>(root.right == <span class="hljs-keyword">null</span>) &#123;            returnType left_part = helper(root.left);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> returnType(root.val, left_part.minV, root.val &gt; left_part.maxV &amp;&amp; left_part.isValid);        &#125;        returnType right_part = helper(root.right);        returnType left_part = helper(root.left);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> returnType(right_part.maxV, left_part.minV, left_part.maxV &lt; root.val &amp;&amp; right_part.minV &gt; root.val &amp;&amp; right_part.isValid &amp;&amp; left_part.isValid);    &#125;    &#125;</code></pre><h2 id="Sort-Colors-II"><a href="#Sort-Colors-II" class="headerlink" title="Sort Colors II"></a><a href="https://www.lintcode.com/problem/sort-colors-ii/description">Sort Colors II</a></h2><p>Description:<br>Given an array of n objects with k different colors (numbered from 1 to k), sort them so that objects of the same color are adjacent, with the colors in the order 1, 2, … k.<br><img src="https://uploadpicuse.blob.core.windows.net/pictures/1588749539(1).png"><br>思路：类似于快速排序，根据中间的颜色的数partition，左边小于中间的颜色，右边大于中间的颜色，然后两边继续做同样的操作。  </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> colors: A list of integer</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> k: An integer</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: nothing</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] colors, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-comment">// write your code here</span>        sortColors2(colors, k, <span class="hljs-number">0</span>, colors.length - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, k);    &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] colors, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> from, <span class="hljs-keyword">int</span> to)</span> </span>&#123;        <span class="hljs-comment">// write your code here</span>        <span class="hljs-keyword">if</span>(left == right) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span>(from == to) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">int</span> l = left, r = right;        <span class="hljs-keyword">int</span> mid = (to - from) / <span class="hljs-number">2</span> + from;        <span class="hljs-keyword">while</span>(l &lt;= r) &#123;            <span class="hljs-keyword">while</span>(l &lt;= r &amp;&amp; colors[l] &lt;= mid) &#123;                l++;            &#125;            <span class="hljs-keyword">while</span>(l &lt;= r &amp;&amp; colors[r] &gt; mid) &#123;                r--;            &#125;            <span class="hljs-keyword">if</span>(l &lt;= r) &#123;                <span class="hljs-keyword">int</span> temp = colors[l];                colors[l] = colors[r];                colors[r] = temp;                l++;                r--;            &#125;        &#125;        sortColors2(colors, k, left, l, from, mid);        sortColors2(colors, k, l, right, mid + <span class="hljs-number">1</span>, to);    &#125;&#125;</code></pre><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="Paint-House"><a href="#Paint-House" class="headerlink" title="Paint House"></a><a href="https://www.lintcode.com/problem/paint-house/description">Paint House</a></h2><p>Description:<br>There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color, and you need to cost the least. Return the minimum cost.<br>The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on… Find the minimum cost to paint all houses.<br><img src="https://uploadpicuse.blob.core.windows.net/pictures/68747470733a2f2f75706c6f61642e63632f69312f323032302f30342f31322f46564a714d672e706e67.png"><br>思路：使用动态规划，第i个房子的颜色与第i-1个房子的颜色不同，且为涂到第i-1个房子的费用最小值+第i个房子的费用。建立二维数组，helper[i][j]代表第i个房子涂第j个颜色时的总费用最小值。<br>转移方程为：f[i][j] = min{f[n-1][k]} + costs[i][j != k]<br>(可以使用[2][3]的滚动数组节省空间，第i个房子的颜色/费用只与第i-1个房子的颜色/费用有关)</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> costs: n x 3 cost matrix</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: An integer, the minimum cost to paint all houses</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minCost</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] costs)</span> </span>&#123;        <span class="hljs-comment">// write your code here</span>        <span class="hljs-keyword">if</span>(costs == <span class="hljs-keyword">null</span> || costs.length == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;                <span class="hljs-keyword">int</span>[][] helper = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[costs.length][<span class="hljs-number">3</span>];        helper[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = costs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];        helper[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = costs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];        helper[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = costs[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; costs.length; i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;                helper[i][j] = Integer.MAX_VALUE;            &#125;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">3</span>; k++) &#123;                    <span class="hljs-keyword">if</span>(k != j &amp;&amp; helper[i - <span class="hljs-number">1</span>][k] + costs[i][j] &lt; helper[i][j]) &#123;                        helper[i][j] = helper[i - <span class="hljs-number">1</span>][k] + costs[i][j];                    &#125;                &#125;            &#125;        &#125;                <span class="hljs-keyword">int</span> result = helper[costs.length - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];        <span class="hljs-keyword">if</span>(helper[costs.length - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &lt; result) &#123;            result = helper[costs.length - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">if</span>(helper[costs.length - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] &lt; result) &#123;            result = helper[costs.length - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><h2 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a><a href="https://leetcode-cn.com/problems/word-break/">单词拆分</a></h2><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。<br>说明：<br>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br><img src="https://s1.ax1x.com/2020/08/04/aD104U.png">  </p><p>思路：转移方程为dp[i] = dp[j] &amp;&amp; wordDict.contains(s[j:i])</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;        Set&lt;String&gt; words = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(wordDict);        <span class="hljs-keyword">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[s.length() + <span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= s.length(); i++) &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;                <span class="hljs-keyword">if</span>(dp[j] == <span class="hljs-keyword">true</span> &amp;&amp; words.contains(s.substring(j, i))) &#123;                    dp[i] = <span class="hljs-keyword">true</span>;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[s.length()];    &#125;&#125;</code></pre><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a><a href="https://leetcode-cn.com/problems/sort-colors/">颜色分类</a></h2><p><img src="https://s1.ax1x.com/2020/08/05/ayRD5q.png"><br>思路：左指针 - 0的结束，右指针 - 2的开始，curr左边为1的区域，右边为未知区域。<br>如图将原数组分为全0区域、全2区域，全1区域，未知区域，其中全0和全2就是处理后的区域，全1区域就是不需要的区域。<br><img src="https://s1.ax1x.com/2020/08/05/ayRqMD.png">  </p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> p0 = <span class="hljs-number">0</span>, p2 = nums.length - <span class="hljs-number">1</span>, curr = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(curr &lt;= p2) &#123;            <span class="hljs-keyword">if</span>(nums[curr] == <span class="hljs-number">0</span>) &#123;                exch(nums, curr, p0);                p0++;                curr++;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[curr] == <span class="hljs-number">2</span>) &#123;                exch(nums,curr, p2);                p2--;            &#125;            <span class="hljs-keyword">else</span> &#123;                curr++;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">int</span> temp = nums[a];        nums[a] = nums[b];        nums[b] = temp;    &#125;&#125;</code></pre><h2 id="3sum"><a href="#3sum" class="headerlink" title="3sum"></a><a href="https://www.lintcode.com/problem/3sum/description">3sum</a></h2><p>Description:<br>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.<br><img src="https://s1.ax1x.com/2020/08/04/aD3tRe.png"><br>思路：将问题转化成two sum，把数组排序，定义左右指针和target值，此时numbers[left]+number[right]如果小于target，则只能将左指针右移，反之同理。注意重复值应跳过。  </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> numbers: Give an array numbers of n integer</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: Find all unique triplets in the array which gives the sum of zero.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] numbers) &#123;        <span class="hljs-comment">// write your code here</span>        Arrays.sort(numbers);        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span>(numbers == <span class="hljs-keyword">null</span> || numbers.length &lt; <span class="hljs-number">3</span>) &#123;            <span class="hljs-keyword">return</span> result;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.length - <span class="hljs-number">2</span>; i++) &#123;            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; numbers[i] == numbers[i - <span class="hljs-number">1</span>]) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            twoSum(numbers, i + <span class="hljs-number">1</span>, numbers.length - <span class="hljs-number">1</span>, -numbers[i], result);        &#125;        <span class="hljs-keyword">return</span> result;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] numbers, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> target, List&lt;List&lt;Integer&gt;&gt; result)</span> </span>&#123;        <span class="hljs-keyword">int</span> cur = left - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left &lt; right)&#123;            <span class="hljs-keyword">if</span>(numbers[left] + numbers[right] == target) &#123;                List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();                tmp.add(numbers[cur]);                tmp.add(numbers[left]);                tmp.add(numbers[right]);                System.out.println(left + <span class="hljs-string">&quot; &quot;</span> + right);                left++;                right--;                result.add(tmp);                <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; numbers[left] == numbers[left - <span class="hljs-number">1</span>]) &#123;                    left++;                &#125;                <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; numbers[right] == numbers[right + <span class="hljs-number">1</span>]) &#123;                    right--;                &#125;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[left] + numbers[right] &lt; target) &#123;                left++;            &#125;            <span class="hljs-keyword">else</span> &#123;                right--;            &#125;        &#125;    &#125;&#125;</code></pre><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><h2 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a><a href="https://leetcode-cn.com/problems/daily-temperatures/">每日温度</a></h2><p><img src="https://s1.ax1x.com/2020/08/03/adKrSP.png"><br>解法一：单调栈  </p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dailyTemperatures(<span class="hljs-keyword">int</span>[] T) &#123;        <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[T.length];        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        stack.push(<span class="hljs-number">0</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; T.length; i++) &#123;            <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; T[i] &gt; T[stack.peek()]) &#123;                result[stack.peek()] = i - stack.peek();                stack.pop();            &#125;            stack.push(i);        &#125;        <span class="hljs-keyword">while</span>(!stack.isEmpty()) &#123;            result[stack.pop()] = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><p>解法二：从后向前  </p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dailyTemperatures(<span class="hljs-keyword">int</span>[] T) &#123;        <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[T.length];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = T.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            <span class="hljs-keyword">if</span>(T[i] &lt; T[i + <span class="hljs-number">1</span>]) &#123;                result[i] = <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">1</span> + result[i + <span class="hljs-number">1</span>];                <span class="hljs-keyword">while</span>(i + tmp &lt;= T.length - <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">if</span>(T[i] &lt; T[i + tmp]) &#123;                        result[i] = tmp;                        <span class="hljs-keyword">break</span>;                    &#125;                    <span class="hljs-keyword">if</span>(result[i + tmp] == <span class="hljs-number">0</span>) &#123;                        result[i] = <span class="hljs-number">0</span>;                        <span class="hljs-keyword">break</span>;                    &#125;                    tmp += result[i + tmp];                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><h1 id="BFS-amp-DFS"><a href="#BFS-amp-DFS" class="headerlink" title="BFS &amp; DFS"></a>BFS &amp; DFS</h1><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">全排列</a></h2><p><img src="https://s1.ax1x.com/2020/08/06/aR33Q0.png"><br>思路：回溯法 + DFS，每次递归前将该数字设为used，递归结束后回溯到原来not used的状态  </p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length];        dfs(nums, used, res, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;());        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">boolean</span>[] used, List&lt;List&lt;Integer&gt;&gt; res, <span class="hljs-keyword">int</span> length, ArrayList&lt;Integer&gt; cur_array)</span> </span>&#123;        <span class="hljs-keyword">if</span>(length == nums.length) &#123;            res.add(<span class="hljs-keyword">new</span> ArrayList(cur_array));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">if</span>(!used[i]) &#123;                cur_array.add(nums[i]);                used[i] = <span class="hljs-keyword">true</span>;                dfs(nums, used, res, length + <span class="hljs-number">1</span>, cur_array);                cur_array.remove(cur_array.size() - <span class="hljs-number">1</span>);                used[i] = <span class="hljs-keyword">false</span>;            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="重新安排行程"><a href="#重新安排行程" class="headerlink" title="重新安排行程"></a><a href="https://leetcode-cn.com/problems/reconstruct-itinerary/">重新安排行程</a></h2><p><img src="https://s1.ax1x.com/2020/08/27/d5ZTLd.png"><br>思路： 欧拉回路 / 欧拉通路，注意当我们贪心地选择字典序最小的节点前进时，可能先走入「死胡同」<br>使用<em>Hierholzer 算法</em>，逆序入栈  </p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    Map&lt;String, PriorityQueue&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; tickets)</span> </span>&#123;               <span class="hljs-keyword">if</span>(tickets.size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;                <span class="hljs-keyword">for</span>(List&lt;String&gt; l : tickets) &#123;            String src = l.get(<span class="hljs-number">0</span>), dest = l.get(<span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(!map.containsKey(src)) &#123;                map.put(src, <span class="hljs-keyword">new</span> PriorityQueue&lt;String&gt;());            &#125;            map.get(src).add(dest);        &#125;               dfs(<span class="hljs-string">&quot;JFK&quot;</span>);        Collections.reverse(res);        <span class="hljs-keyword">return</span> res;    &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">while</span>(map.containsKey(s) &amp;&amp; !map.get(s).isEmpty()) &#123;            String next = map.get(s).poll();            dfs(next);        &#125;        res.add(s);    &#125;&#125;</code></pre><h1 id="Other-records"><a href="#Other-records" class="headerlink" title="Other records"></a>Other records</h1><h2 id="Tree-Iterator-without-using-recursion"><a href="#Tree-Iterator-without-using-recursion" class="headerlink" title="Tree Iterator without using recursion"></a>Tree Iterator without using recursion</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition of TreeNode:</span><span class="hljs-comment"> * public class TreeNode &#123;</span><span class="hljs-comment"> *     public int val;</span><span class="hljs-comment"> *     public TreeNode left, right;</span><span class="hljs-comment"> *     public TreeNode(int val) &#123;</span><span class="hljs-comment"> *         this.val = val;</span><span class="hljs-comment"> *         this.left = this.right = null;</span><span class="hljs-comment"> *     &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> * Example of iterate a tree:</span><span class="hljs-comment"> * BSTIterator iterator = new BSTIterator(root);</span><span class="hljs-comment"> * while (iterator.hasNext()) &#123;</span><span class="hljs-comment"> *    TreeNode node = iterator.next();</span><span class="hljs-comment"> *    do something for node</span><span class="hljs-comment"> * &#125; </span><span class="hljs-comment"> */</span> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BSTIterator</span> </span>&#123;    <span class="hljs-keyword">private</span> Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-comment">// @param root: The root of binary tree.</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BSTIterator</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;            stack.push(root);            root = root.left;        &#125;    &#125;    <span class="hljs-comment">//@return: True if there has next node, or false</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> !stack.isEmpty();    &#125;        <span class="hljs-comment">//@return: return next node</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;        TreeNode curt = stack.peek();        TreeNode node = curt;                <span class="hljs-comment">// move to the next node</span>        <span class="hljs-keyword">if</span> (node.right == <span class="hljs-keyword">null</span>) &#123;            node = stack.pop();            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().right == node) &#123;                node = stack.pop();            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            node = node.right;            <span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span>) &#123;                stack.push(node);                node = node.left;            &#125;        &#125;                <span class="hljs-keyword">return</span> curt;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解决MySQL的encoding问题</title>
    <link href="/2020/04/06/2020-04-06-%E8%A7%A3%E5%86%B3MySQL%E7%9A%84encoding%E9%97%AE%E9%A2%98/"/>
    <url>/2020/04/06/2020-04-06-%E8%A7%A3%E5%86%B3MySQL%E7%9A%84encoding%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>解决MySQL无法正常显示emoji及一些小语种的问题</p></blockquote><a id="more"></a><p>在load数据的时候发现MySQL无法正常显示emoji和日语、阿拉伯语等等的语言，主要原因是没有使用utf8mb4编码，可以通过以下操作解决                                                                                                                                                                                                      </p><ol><li><p>查看当前MySQL的编码，会发现使用的是latin  </p><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">VARIABLES</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%character_set_%&#x27;</span>;</code></pre></li><li><p>改变当前数据的encoding  </p><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">DATABASE</span> &lt;your_database&gt; <span class="hljs-built_in">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci;</code></pre></li><li><p>修改配置文件 /etc/mysql/mysql.conf.d/mysqld.cnf<br>直接再最后加上：  </p><pre><code class="hljs ini"><span class="hljs-section">[client]</span>  <span class="hljs-attr">default-character-set</span> = utf8mb4  <span class="hljs-section">[mysql]</span>  <span class="hljs-attr">default-character-set</span> = utf8mb4  <span class="hljs-section">[mysqld]</span>  <span class="hljs-attr">character-set-client-handshake</span> = <span class="hljs-literal">FALSE</span>  <span class="hljs-attr">character-set-server</span> = utf8mb4  <span class="hljs-attr">collation-server</span> = utf8mb4_unicode_ci</code></pre></li><li><p>重启MySQL  </p><pre><code class="hljs routeros">sudo<span class="hljs-built_in"> service </span>restart mysql</code></pre></li></ol><p>搞定！最后可以再确定一下encoding，应该会有如下的显示：   </p><p><img src="https://upload.cc/i1/2020/04/06/dN9Eop.png" alt="Encoding"></p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Cloud Computing笔记 - MapReduce &amp; Hadoop</title>
    <link href="/2020/04/05/2020-04-05-%E4%BA%91%E8%AE%A1%E7%AE%97%20Cloud%20Computing/"/>
    <url>/2020/04/05/2020-04-05-%E4%BA%91%E8%AE%A1%E7%AE%97%20Cloud%20Computing/</url>
    
    <content type="html"><![CDATA[<p>主要是15-619（15-319）这节课的内容，我这么懒的人，不一定能完完整整都记下来哈哈哈</p><a id="more"></a>  <p>云计算这课上到现在基本算是结束了，这节课上下来的感觉并没传说中那么恐怖，当然也没有多轻松。<br>确实接触了挺多新的工具和知识，HBase/Spark/Hadoop/MapReduce/Docker/k8s等等等等，最尴尬的是面试的时候会被说学了很多但哪一个都没有深入的研究下去。写写博客总结一下这一学期cc的project，顺便也再学习一遍。</p><h3 id="MapReduce-amp-Hadoop"><a href="#MapReduce-amp-Hadoop" class="headerlink" title="MapReduce &amp; Hadoop"></a>MapReduce &amp; Hadoop</h3><p><img src="https://s3.amazonaws.com/cmucc-public/15619public/webcontent/mapReduce_analytics_engine.png" alt="MapReduce"><br>MapReduce由两部分组成，Map Phase和Reduce Phase，Map Phase由一个或多个相同的Map task组成，Reduce Phase则由零个或多个相同的Reduce task组成。<br>Map就是把数据转为Key/Value Pair的形式，Reduce则是完成一个类似于group by的操作。<br>以经典的word count为例：  </p><ul><li>Map task的输入为”the boy ate the apple”  </li><li>Map task的输出为(the, 1), (boy, 1), (ate, 1), (the, 1), (apple, 1)</li><li>经过sort和shuffle stage，具有相同key的intermediate Key/Value pairs将被放入同一个reducer中</li><li>The reduce task will aggregate the counts for the same word </li><li>If you had a single reduce task that is processing all possible keys, then the input will be (the, list(1,1)), (boy, list(1)), (ate, list(1)), (apple, list(1)) and the output will be: (the, 2), (boy, 1), (ate, 1), (apple, 1)<br><img src="https://upload.cc/i1/2020/04/05/MgQnEa.png" alt="MapReduce">   </li></ul><p>在MapReduce中还有一步操作是Combine，Combine使用的方法就是Reduce。我们可以在Map Phase中先对key进行aggregate，如下图：<br><img src="https://s3.amazonaws.com/cmucc-public/15619public/webcontent/p12/map-reduce-combiner.png" alt="MapReduce"> </p><p>需要根据情况判断是否使用Combiner。在word count这个例子中，使用combiner可以提升效率，总体的和是部分和的加总。但如果我们算的是平均值，使用combiner则会导致结果错误，总体的平均并不是部分平均值的平均。</p>]]></content>
    
    
    <categories>
      
      <category>cloudcomputing</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2019年的读书总结</title>
    <link href="/2020/01/07/2020-01-07-2019%E5%B9%B4%E7%9A%84%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    <url>/2020/01/07/2020-01-07-2019%E5%B9%B4%E7%9A%84%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>2019年很闲，闲到读了很多书，博客很久没更新过，干脆记录一下去年读过的书好了。年度最爱竟然是！是麻耶雄嵩的《有翼之暗》！</p><a id="more"></a><h2 id="推理部门（有点泄底）"><a href="#推理部门（有点泄底）" class="headerlink" title="推理部门（有点泄底）"></a>推理部门（有点泄底）</h2><h3 id="麻耶雄嵩"><a href="#麻耶雄嵩" class="headerlink" title="麻耶雄嵩"></a>麻耶雄嵩</h3><p>《<a href="https://book.douban.com/subject/11607283/">萤</a>》<br>麻耶雄嵩是个很坑爹的作者。不仔仔细细读这本书的话，99.9%的概率需要读第二遍，性别叙诡真是有点那个，虽然多读几本坑爹的新本格推理会提高警惕，但还是很想骂人：）</p><p>《<a href="https://book.douban.com/subject/25892396/">有翼之暗</a>》<br>我很喜欢的一本书，还是麻耶雄嵩最擅长的崩坏流。古宅、家族秘密、猎奇的连续死亡、神秘的少女，日系推理的要素真是相当完备。解答三次转折，不读到结尾永远得不到真相。</p><p>《<a href="https://book.douban.com/subject/26936111/">神的游戏</a>》<br>开头是快乐的少年侦探团（我真的很喜欢柯南里的少年侦探团，无忧无虑的几个小学生不咋上学天天跟着阿笠博士和毛利shu（三声）shu（二声）满世界乱跑，うらやましい），没想到又又又又是崩坏流，崩坏到仙女座星系了，但有一说一，我还挺喜欢。豆瓣评分8.4，我看是因为读的人很少吧。</p><h3 id="西泽保彦"><a href="#西泽保彦" class="headerlink" title="西泽保彦"></a>西泽保彦</h3><p>《<a href="https://book.douban.com/subject/27078155/">解体诸因</a>》<br>很有趣的小黄书（指书皮是黄色的），几个主题相似的推理短篇。推理最能唬人的一点就是要血腥，最血腥的操作就是分尸，本书探讨了凶手们为什么要分尸的心路历程。</p><p>《<a href="https://book.douban.com/subject/27055125/">死了七次的男人</a>》<br>统称七死男，和《<a href="https://book.douban.com/subject/27078155/">解体诸因</a>》一样算是西泽保彦的代表作了。幻想推理，这个叫法很有意思，尽管我觉得没有很多推理成分，硬说的话也算叙诡吧。西泽保彦这人讲故事太啰嗦，看题目“死了七次”，每次的经历没差太多却一统描写，看到第四五次的时候很想撕书哦。</p><p>《<a href="https://book.douban.com/subject/26373943/">她死去的那一晚</a>》<br>《<a href="https://book.douban.com/subject/27200982/">替身</a>》<br>给我留下的印象不很深的两本，搁一起说了。前一本的手法还算可圈可点，后一本我不是特别喜欢。总的来说就是四人组匠仔、高千、小兔和漂撇学长喝酒聊天推理破案的故事。</p><h3 id="江户川乱步"><a href="#江户川乱步" class="headerlink" title="江户川乱步"></a>江户川乱步</h3><p>《<a href="https://book.douban.com/subject/6558049/">阴兽</a>》<br>《<a href="https://book.douban.com/subject/6558046/">人间椅子</a>》<br>变态推理文学，没了。</p><h3 id="埃勒里·奎因"><a href="#埃勒里·奎因" class="headerlink" title="埃勒里·奎因"></a>埃勒里·奎因</h3><p>《<a href="https://book.douban.com/subject/26915344/">X的悲剧</a>》<br>人名太难记了，还有我希望全世界的侦探可以调查到了什么就直接说出来！</p><p>《<a href="https://book.douban.com/subject/26915345/">Y的悲剧</a>》<br>哲瑞•雷恩真是心狠手辣，审判命运这种事请交给法庭。</p><h3 id="阿加莎·克里斯蒂"><a href="#阿加莎·克里斯蒂" class="headerlink" title="阿加莎·克里斯蒂"></a>阿加莎·克里斯蒂</h3><p>我真的不适合读欧美的推理小说唉。阿婆的书太多了，去年决定读完马普尔小姐系列，结果只读了9本。每本内容不多，在手机上读平均每本也就是400-500页的样子，手法也不复杂，我说是日系推理的饭后甜点吧。总之，马普尔这位老小姐很可爱啊！  </p><h5 id="马普尔小姐系列"><a href="#马普尔小姐系列" class="headerlink" title="马普尔小姐系列"></a>马普尔小姐系列</h5><p>《<a href="https://book.douban.com/subject/21617613/">寓所谜案</a>》<br>马普尔小姐系列的第一本，剧情全忘了，骚凹瑞阿婆。</p><p>《<a href="https://book.douban.com/subject/24358966/">藏书室女尸之谜</a>》<br>大名鼎鼎戈辛顿庄园第一案，很平淡，人还不是在戈辛顿庄园死的。</p><p>《<a href="https://book.douban.com/subject/30245148/">死亡草</a>》<br>目前为止马普尔小姐系列最喜欢的一本，短篇集，说起来我真的很喜欢推理短篇。</p><p>《<a href="https://book.douban.com/subject/25877118/">魔手</a>》<br>剧情全忘了，骚凹瑞阿婆。</p><p>《<a href="https://book.douban.com/subject/25928086/">谋杀启事</a>》<br>这个系列的代表作，身份替换这个手法在《<a href="https://book.douban.com/subject/30245148/">死亡草</a>》用过了，没意思。</p><p>《<a href="https://book.douban.com/subject/26376888/">借镜杀人</a>》<br>剧情全忘了，骚凹瑞阿婆。我看《<a href="https://book.douban.com/subject/25986370/">破镜谋杀案</a>》的时候还认真想了一下这本有没有读过，真是幸亏在豆瓣上标记了。</p><p>《<a href="https://book.douban.com/subject/30174285/">黑麦奇案</a>》<br>童谣杀人第二案！</p><p>《<a href="https://book.douban.com/subject/26253719/">命案目睹记</a>》<br>窗外看见了并排行驶的另一列火车上发生的谋杀案，这个场景有点点吓人。</p><p>《<a href="https://book.douban.com/subject/25986370/">破镜谋杀案</a>》<br>我想阿婆很后悔没有给戈辛顿庄园安排一次”真正的“谋杀案，这一本四个人死在了庄园里，可惜的是阿婆实在不适合写连续杀人案。日本拍过这本的推理SP，黑木瞳演的那位女演员，从此她演什么我都觉得像凶手。</p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>《<a href="https://book.douban.com/subject/21371175/">罗杰疑案</a>》<br>本书的手法搁当时来说是相当新颖，搁现在讲就是烂大街。</p><p>《<a href="https://book.douban.com/subject/25929085/">阳光下的罪恶</a>》<br>在太阳底下，到处都有邪恶的事。</p><p>《<a href="https://book.douban.com/subject/25835911/">幸福假面</a>》<br>这本不是推理小说，而且我超级不喜欢，阿婆这个”心之罪“系列我或许不会再读了。我读完的感受就是疑惑这可能是英国女德教育。</p><h3 id="其他作者"><a href="#其他作者" class="headerlink" title="其他作者"></a>其他作者</h3><p>乙一 —— 《<a href="https://book.douban.com/subject/34778574/">夏天、烟火和我的尸体</a>》<br>我想江户川乱步后继有人了，够变态，够吓人，小朋友就很恐怖了，小朋友干谋杀抛尸这种事还有没有辙了。</p><p>冈岛二人 —— 《<a href="https://book.douban.com/subject/33658616/">克莱因壶</a>》<br>就是《盗梦空间》那套，但一看是1989年的书，惊到了，那可够牛逼的。</p><p>岛田庄司 —— 《<a href="https://book.douban.com/subject/10740772/">斜屋犯罪</a>》<br>2019年才读岛田老师的这本书，罪过！前言讲得挺好，“一间密室之内，有人死于非命，凶手人间蒸发，此为本格派；有人死于非命，凶手人间蒸发，并在尸体四周建密室一间，此谓新本格派”。</p><h2 id="非推理部门"><a href="#非推理部门" class="headerlink" title="非推理部门"></a>非推理部门</h2><h3 id="那不勒斯四部曲"><a href="#那不勒斯四部曲" class="headerlink" title="那不勒斯四部曲"></a>那不勒斯四部曲</h3><p>埃莱娜·费兰特 —— 《<a href="https://book.douban.com/subject/26878124/">我的天才女友</a>》 《<a href="https://book.douban.com/subject/27104959/">新名字的故事</a>》 《<a href="https://book.douban.com/subject/27104959/">离开的，留下的</a>》 《<a href="https://book.douban.com/subject/30172069/">失踪的孩子</a>》<br>因为被拍成了剧，这套书前几年真是名声大噪，我慕名去读了，读的时候只有俩字儿——生气！女主莱农对于爱情很没脑子，我十分读不懂这个角色。男主（？）尼诺则是一位绝世大渣男，说着厌恶父亲的多情，自己却已经成为了父亲那样的人。之前看ARASHI那部《<a href="https://movie.douban.com/subject/25905892/">生活艰难也许快乐</a>》，年轻的我们也是看着船上喝酒的社畜和朋友说着绝对不会成为这样的人，最终却还是一起上了那艘船，变成了最讨厌的那种大人。<br>说回来四本书的中心思想还是莱农和莉拉一生的友情，莉拉那句 “但你不一样，你是我的天才朋友，你应该比任何人都要厉害，无论是男生还是女生” 让我有点点感动，真的是完完整整地写完了一生啊。</p><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><p>三浦紫苑 —— 《<a href="https://book.douban.com/subject/26210487/">强风吹拂</a>》<br>“教练，我想要跑步！”</p>]]></content>
    
    
    <categories>
      
      <category>reading</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Sorting Algorithms</title>
    <link href="/2019/10/06/2019-10-06-Sorting-Algorithms/"/>
    <url>/2019/10/06/2019-10-06-Sorting-Algorithms/</url>
    
    <content type="html"><![CDATA[<p>📙 MY NOTEBOOK FOR <a href="https://www.coursera.org/learn/algorithms-part1/home/welcome">Algorithms - Princeton</a>                                                                                             </p><a id="more"></a><p>👾 You need to add <a href="https://algs4.cs.princeton.edu/code/algs4.jar">algs4.jar</a> to your library to compile the codes. </p><h1 id="Useful-Sorting-Functions"><a href="#Useful-Sorting-Functions" class="headerlink" title="Useful Sorting Functions"></a>Useful Sorting Functions</h1><p><strong>Less</strong>: Is item v less than w?  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">less</span><span class="hljs-params">(Comparable v, Comparable w)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> v.compareTo(w) &lt; <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>Exchange</strong>: Swap item in array a[] at index i with the one at index j.  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exch</span><span class="hljs-params">(Comparable[] a, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span>  <span class="hljs-comment">// NOTICE: the type of the array is Comparable.</span></span><span class="hljs-function"></span>&#123;Comparable swap = a[i];a[i] = a[j];a[j] = a[i];&#125;</code></pre><h1 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a>Selection Sort</h1><p>That’s so easy. You just need to scan from the begining to the end and find the smallest item, exchange them and do it again and again and again. A little bit boring…😅<br>Selection sort uses (N-1) + (N-2) + … + 1 + 0 ~ <strong>N^2 / 2</strong> compares and <strong>N</strong> exchanges.  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> N = a.length;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)&#123;<span class="hljs-keyword">int</span> min = i;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; N; j++)&#123;<span class="hljs-keyword">if</span>(less(a[j], a[min]) min = j;&#125;exch(a, i, min);&#125;&#125;</code></pre><h1 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h1><p>Well, that’s also easy…😀  </p><p>But you must know insertion sort performs well when the array is nearly sorted. In insertion sort, we just have to make sure that the part we have already scanned is sorted, the rest part we don’t care.<br>So in iteration i, as long as a[i] is smaller than its left, we swap it and its left item until it is no less then its left.  </p><p>On average, insertion sort uses ~1/4N^2 compares and ~1/4N^2 exchanges. In the worst case, insertion sort uses ~1/2N^2 compares and ~1/2N^2 exchanges. But for <strong>partially sorted arrays</strong>, insertion sort runs in linear time.<br>😅 Sorry I always don’t know how to calculate the average situation, I prefer to use Big-O. And both selection sort and insertion sort are O(n^2).   </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> N = a.length;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N - <span class="hljs-number">1</span>; i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i; j &gt; <span class="hljs-number">0</span>; j--)&#123;<span class="hljs-keyword">if</span>(less(a[j], a[j -<span class="hljs-number">1</span>])exch(a, j, j - <span class="hljs-number">1</span>);<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;&#125;&#125;&#125;</code></pre><h3 id="Improvement-Shell-Sort"><a href="#Improvement-Shell-Sort" class="headerlink" title="Improvement: Shell Sort"></a>Improvement: Shell Sort</h3><p>Why not make our array partially sorted and than use insertion sort?<br>🤔Shellsort: h-sort array for decreasing sequence of values of h.<br><img src="https://upload.cc/i1/2019/10/07/DlkZeV.png" alt="3-sorting">  </p><p>Which increment sequence to use?  <strong>3x + 1</strong> (1, 4, 13, 40, 121, 364, …)  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> N = a.length;<span class="hljs-keyword">int</span> h = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(h &lt; N / <span class="hljs-number">3</span>) h = <span class="hljs-number">3</span> * h + <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(h &gt;= <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h; i &lt; N; i++)&#123;<span class="hljs-keyword">int</span> j = i;<span class="hljs-keyword">while</span>(j &gt;= h &amp;&amp; less(a[j], a[j - h]) exch(a, j, j - h);j -= h;<span class="hljs-comment">// for(int j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]) ; j-=h) exch(a, j, j - h);</span>&#125;h = h / <span class="hljs-number">3</span>;  <span class="hljs-comment">// When h = 1, it&#x27;s insertion sort.</span>&#125;&#125;</code></pre><p>The worst-case number of compares used by shellsort with 3x+1 increment is <strong>O( N^(3/2) )</strong></p><h1 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h1><p>As its name, there are two steps in the merge sort (omg, just TWO steps) - merge and sort.  </p><h3 id="STEP-ONE-Merge"><a href="#STEP-ONE-Merge" class="headerlink" title="STEP ONE: Merge"></a>STEP ONE: Merge</h3><p>Consider this question, when there are two already sorted array, assigned a[i] and b[j], and we want to sort them into one big array. This is a simple question, you need two pointers and find which pointer is pointed to a smaller item, select this element and add this pointer. And also, we need extra space to store that element.<br>Now consider the same question in one single array.<br><img src="https://upload.cc/i1/2019/10/07/4957Hm.png" alt="enter description here"><br>We need to sort these two parts and get a full-sorted array. Given two sorted subarrays a[lo] to a[mid] and a[mid+1] to a[hi], replace with sorted subarray a[lo] to a[hi]. This is <strong>merge</strong>.  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(Comparable[] a, Comparable[] aux, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> hi)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = lo; k &lt;= hi; k++)&#123;aux[k] = a[k];&#125;<span class="hljs-keyword">int</span> i = lo, j = mid + <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = lo; k &lt;= hi; k++)&#123;<span class="hljs-keyword">if</span>(i &gt; mid) a[k] = a[j++];  <span class="hljs-comment">// When all the items in the left part have been added to the final array.</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j &gt; hi) a[k] = a[i++]; <span class="hljs-comment">// When all the items in the right part have been added to the final array.</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(less(aux[i], aux[j]) a[k] = a[i++];<span class="hljs-keyword">else</span> a[k] = a[j++];&#125;&#125;</code></pre><h3 id="STEP-TWO-Sort"><a href="#STEP-TWO-Sort" class="headerlink" title="STEP TWO: Sort"></a>STEP TWO: Sort</h3><p><img src="https://www.smbc-comics.com/comics/1562409923-20190706.png" alt="Recursion"><br>Merge sort uses recursion and I’m really not good at recursion😣.</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a, Comparable[] aux, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span></span>&#123;<span class="hljs-keyword">if</span>(lo == hi) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">int</span> mid = lo + (hi - lo) / <span class="hljs-number">2</span>;sort(a, aux, lo, mid);sort(a, aux, mid + <span class="hljs-number">1</span>, hi);merge(a, aux, lo, mid, hi);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a)</span></span><span class="hljs-function"></span>&#123;Comparable[] aux = <span class="hljs-keyword">new</span> Comparable[a.length];  <span class="hljs-comment">// You don&#x27;t have to initialize aux each time.</span>sort(a, aux, <span class="hljs-number">0</span>, a.length - <span class="hljs-number">1</span>);&#125;</code></pre><h3 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h3><p>Merge sort uses at most NlgN compares and extra sapce proportional to N.</p><ol><li>Use insertion sort for small subarrays. Cutoff to insertion sort for ~7 items.</li><li>Stop if already sorted. Is biggest item in first half &lt;= smallest item in second half?</li><li>Eliminate the copy to the auxiliary array. Save time, not space. Switching the role of the input and auxiliary array in each recursive call.</li></ol><h3 id="No-recursive-Bottom-up-mergesort"><a href="#No-recursive-Bottom-up-mergesort" class="headerlink" title="No recursive?  Bottom-up mergesort"></a>No recursive?  Bottom-up mergesort</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> N = a.length;Comparable[] a = <span class="hljs-keyword">new</span> Comparable[a.length];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> sz = <span class="hljs-number">1</span>; sz &lt; N; sz = sz + sz)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>; lo &lt; N - sz + <span class="hljs-number">1</span>; lo += sz)&#123;merge(a, aux, lo, lo + sz - <span class="hljs-number">1</span>, Math.min(lo + sz + sz - <span class="hljs-number">1</span>, N-<span class="hljs-number">1</span>));&#125;&#125;&#125;</code></pre><h1 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h1><h3 id="STEP-ONE-Shuffle-the-array"><a href="#STEP-ONE-Shuffle-the-array" class="headerlink" title="STEP ONE:  Shuffle the array"></a>STEP ONE:  Shuffle the array</h3><p><img src="https://upload.cc/i1/2019/10/07/fnmMWh.png"><br>Make the array randomly sorted. For instance, if the array is increased, it would be inefficient, patitioning doesn’t do anything. Why not use insertion sort in this case?  </p><p>*<strong>Knuth Shuffle</strong>: In iteration i, pick integer r between 0 and i uniformly at random.*</p><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shuffle</span><span class="hljs-params">(Obeject[] a)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> N = a.length;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)&#123;<span class="hljs-keyword">int</span> r = StdRandom.uniform(i + <span class="hljs-number">1</span>);   <span class="hljs-comment">// Generate random number rom the beginning to current location. NOTICE: not from 0 to N-1, but from i to N-1 is OK.</span>exch(a, i , r);&#125;&#125;</code></pre><h3 id="STEP-TWO-Partition"><a href="#STEP-TWO-Partition" class="headerlink" title="STEP TWO:  Partition"></a>STEP TWO:  Partition</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(Comparable[] a, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> i = lo, j = hi + <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<span class="hljs-keyword">while</span>(less(a[++i], a[lo]))<span class="hljs-keyword">if</span>(i == hi) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">while</span>(less(a[lo], a[--j]))<span class="hljs-keyword">if</span>(j == lo) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">if</span>(i &gt;= j) <span class="hljs-keyword">break</span>;exch(a, i , j);&#125;exch(a, lo, j);<span class="hljs-keyword">return</span> j;&#125;</code></pre><h3 id="STEP-THREE-Sort"><a href="#STEP-THREE-Sort" class="headerlink" title="STEP THREE:  Sort"></a>STEP THREE:  Sort</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(hi &lt;= lo) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">//So we can see if there is one element in this time of sorting, it will straightly return, this helps improve efficiency. </span><span class="hljs-keyword">int</span> j = partition(a, lo, hi);sort(a, lo, j - <span class="hljs-number">1</span>);  <span class="hljs-comment">//Recursion</span>sort(a, j + <span class="hljs-number">1</span>, hi);&#125;</code></pre><h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p><img src="https://upload.cc/i1/2019/10/07/Ja9Ovg.gif">  </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quick</span></span><span class="hljs-class"></span>&#123;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(Comparable[] a, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span></span><span class="hljs-function"></span>&#123;......&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span></span><span class="hljs-function"></span>&#123;......&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a)</span>  <span class="hljs-comment">//Overload</span></span><span class="hljs-function"></span>&#123;StdRandom.shuffle(a);sort(a, <span class="hljs-number">0</span>, a.length - <span class="hljs-number">1</span>);&#125;&#125;</code></pre><h3 id="Improvement-3-way-quicksort"><a href="#Improvement-3-way-quicksort" class="headerlink" title="Improvement : 3-way quicksort"></a>Improvement : 3-way quicksort</h3><p>When there are lots of duplicate elements in the array, using quick sort is not efficient.<br>😈 <strong>~1/2N^2 compares when all keys are equal.</strong> Since each time, the partition doesn’t work and you have to iterate the other side. Using Dijkstra’s 3-way partitioning.  </p><p><em>Dutch national flag problem</em>: <a href="https://en.wikipedia.org/wiki/Dutch_national_flag_problem">https://en.wikipedia.org/wiki/Dutch_national_flag_problem</a><br>😀 <strong>N*lgN when all distinct.</strong>   </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparable[] a, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(hi &lt;= lo) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">int</span> lt = lo, gt = hi;Comparable v = a[lo];<span class="hljs-keyword">int</span> i = lo;<span class="hljs-keyword">while</span>(i &lt;= gt)&#123;<span class="hljs-keyword">int</span> cmp = a[i].compareTo(v);<span class="hljs-keyword">if</span>(cmp &lt; <span class="hljs-number">0</span>) exch(a, lt++, i++);  <span class="hljs-comment">// a[i] &lt; v, exchange a[lt] with a[i], increment both lt and i</span><span class="hljs-keyword">if</span>(cmp &gt; <span class="hljs-number">0</span>) exch(a, i, gt--);  <span class="hljs-comment">// a[i] &gt; v, exchange a[gt] with a[i], decrement gt</span><span class="hljs-keyword">else</span> i++;  <span class="hljs-comment">// increment i</span>&#125;sort(a, lo, lt - <span class="hljs-number">1</span>);sort(a, gt + <span class="hljs-number">1</span>, hi);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>algorithms</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
